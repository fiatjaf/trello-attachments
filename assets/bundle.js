(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/fiatjaf/comp/trello-browser/index.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
var Promise, Trello, extend, superagent;

Promise = require('lie');

extend = require('xtend');

superagent = (require('superagent-promise'))(require('superagent'), Promise);

Trello = (function() {
  function Trello(key) {
    this.key = key;
    this.get = this.req.bind(this, 'get');
    this.post = this.req.bind(this, 'post');
    this.put = this.req.bind(this, 'put');
    this.del = this.req.bind(this, 'del');
    this["delete"] = this.req.bind(this, 'del');
  }

  Trello.prototype.setToken = function(token) {
    return this.token = token;
  };

  Trello.prototype.auth = function(opts) {
    var defaults, self;
    self = this;
    defaults = {
      type: 'popup',
      name: 'My App',
      scope: {
        read: true,
        write: true,
        account: false
      },
      expiration: '1hour'
    };
    opts = extend(defaults, opts);
    return new Promise(function(resolve, reject) {
      var e, k, popup, timeout;
      popup = window.open("https://trello.com/1/authorize?response_type=token&key=" + self.key + "&return_url=" + location.protocol + "//" + location.host + location.pathname + location.search + "&callback_method=postMessage&scope=" + (((function() {
        var ref, results;
        ref = opts.scope;
        results = [];
        for (k in ref) {
          e = ref[k];
          if (e) {
            results.push(k);
          }
        }
        return results;
      })()).join(',')) + "&expiration=" + opts.expiration + "&name=" + (opts.name.replace(/ /g, '+')), 'trello', "height=606,width=405,left=" + (window.screenX + (window.innerWidth - 420) / 2) + ",right=" + (window.screenY + (window.innerHeight - 470) / 2));
      window.addEventListener('message', function(e) {
        clearTimeout(timeout);
        popup.close();
        self.token = e.data;
        return resolve();
      });
      return timeout = setTimeout((function() {
        popup.close();
        return reject();
      }), 60000);
    });
  };

  Trello.prototype.req = function(method, path, data) {
    var self;
    self = this;
    return Promise.resolve().then(function() {
      var req;
      req = superagent[method]('https://api.trello.com' + path);
      if (method === 'get' || method === 'del') {
        req = req.query({
          key: self.key,
          token: self.token
        }).query(data);
      } else if (data.file && -1 !== path.indexOf('attachments')) {
        req = req.field('name', data.name).field('mimeType', data.mimeType).field('key', self.key).field('token', self.token);
        if (typeof data.file === 'string') {
          if (window.Blob) {
            req = req.attach('file', new File([data.file], data.name, {
              type: data.mimeType
            }), data.name);
          } else {
            req = req.set({
              'Content-Type': 'boundary=----WebKitFormBoundarygZLBN6gxSW5OC5W1'
            }).send("------WebKitFormBoundarygZLBN6gxSW5OC5W1\r\nContent-Disposition: form-data; name=\"name\"\r\n\r\n" + data.name + "\r\n------WebKitFormBoundarygZLBN6gxSW5OC5W1\r\nContent-Disposition: form-data; name=\"mimeType\"\r\n\r\n" + data.mimeType + "\r\n------WebKitFormBoundarygZLBN6gxSW5OC5W1\r\nContent-Disposition: form-data; name=\"key\"\r\n\r\n" + self.key + "\r\n------WebKitFormBoundarygZLBN6gxSW5OC5W1\r\nContent-Disposition: form-data; name=\"token\"\r\n\r\n" + self.token + "\r\n------WebKitFormBoundarygZLBN6gxSW5OC5W1\r\nContent-Disposition: form-data; name=\"file\"; filename=\"" + data.name + "\"\r\nContent-Type: application/octet-stream\r\n\r\n" + data.file + "\r\n------WebKitFormBoundarygZLBN6gxSW5OC5W1--\r\n");
          }
        } else if (typeof data.file === 'object' && data.size) {
          req = req.attach('file', data.file, data.name);
        }
      } else {
        req = req.send({
          key: self.key,
          token: self.token
        }).send(data).set({
          'Content-type': 'application/x-www-form-urlencoded'
        });
      }
      return req.end();
    }).then(function(res) {
      return res.body;
    });
  };

  return Trello;

})();

module.exports = Trello;

module.exports.superagent = superagent;

},{"lie":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/index.js","superagent":"/home/fiatjaf/comp/trello-browser/node_modules/superagent/lib/client.js","superagent-promise":"/home/fiatjaf/comp/trello-browser/node_modules/superagent-promise/index.js","xtend":"/home/fiatjaf/comp/trello-browser/node_modules/xtend/immutable.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/INTERNAL.js":[function(require,module,exports){
'use strict';

module.exports = INTERNAL;

function INTERNAL() {}
},{}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/all.js":[function(require,module,exports){
'use strict';
var Promise = require('./promise');
var reject = require('./reject');
var resolve = require('./resolve');
var INTERNAL = require('./INTERNAL');
var handlers = require('./handlers');
module.exports = all;
function all(iterable) {
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new Promise(INTERNAL);
  
  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len & !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}
},{"./INTERNAL":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/INTERNAL.js","./handlers":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/handlers.js","./promise":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/promise.js","./reject":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/reject.js","./resolve":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/resolve.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/handlers.js":[function(require,module,exports){
'use strict';
var tryCatch = require('./tryCatch');
var resolveThenable = require('./resolveThenable');
var states = require('./states');

exports.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return exports.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    resolveThenable.safely(self, thenable);
  } else {
    self.state = states.FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
exports.reject = function (self, error) {
  self.state = states.REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && typeof obj === 'object' && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

},{"./resolveThenable":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/resolveThenable.js","./states":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/states.js","./tryCatch":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/tryCatch.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/index.js":[function(require,module,exports){
module.exports = exports = require('./promise');

exports.resolve = require('./resolve');
exports.reject = require('./reject');
exports.all = require('./all');
exports.race = require('./race');

},{"./all":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/all.js","./promise":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/promise.js","./race":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/race.js","./reject":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/reject.js","./resolve":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/resolve.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/promise.js":[function(require,module,exports){
'use strict';

var unwrap = require('./unwrap');
var INTERNAL = require('./INTERNAL');
var resolveThenable = require('./resolveThenable');
var states = require('./states');
var QueueItem = require('./queueItem');

module.exports = Promise;
function Promise(resolver) {
  if (!(this instanceof Promise)) {
    return new Promise(resolver);
  }
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = states.PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    resolveThenable.safely(this, resolver);
  }
}

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === states.FULFILLED ||
    typeof onRejected !== 'function' && this.state === states.REJECTED) {
    return this;
  }
  var promise = new Promise(INTERNAL);
  if (this.state !== states.PENDING) {
    var resolver = this.state === states.FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};

},{"./INTERNAL":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/INTERNAL.js","./queueItem":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/queueItem.js","./resolveThenable":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/resolveThenable.js","./states":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/states.js","./unwrap":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/unwrap.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/queueItem.js":[function(require,module,exports){
'use strict';
var handlers = require('./handlers');
var unwrap = require('./unwrap');

module.exports = QueueItem;
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

},{"./handlers":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/handlers.js","./unwrap":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/unwrap.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/race.js":[function(require,module,exports){
'use strict';
var Promise = require('./promise');
var reject = require('./reject');
var resolve = require('./resolve');
var INTERNAL = require('./INTERNAL');
var handlers = require('./handlers');
module.exports = race;
function race(iterable) {
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return resolve([]);
  }

  var i = -1;
  var promise = new Promise(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"./INTERNAL":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/INTERNAL.js","./handlers":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/handlers.js","./promise":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/promise.js","./reject":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/reject.js","./resolve":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/resolve.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/reject.js":[function(require,module,exports){
'use strict';

var Promise = require('./promise');
var INTERNAL = require('./INTERNAL');
var handlers = require('./handlers');
module.exports = reject;

function reject(reason) {
	var promise = new Promise(INTERNAL);
	return handlers.reject(promise, reason);
}
},{"./INTERNAL":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/INTERNAL.js","./handlers":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/handlers.js","./promise":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/promise.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/resolve.js":[function(require,module,exports){
'use strict';

var Promise = require('./promise');
var INTERNAL = require('./INTERNAL');
var handlers = require('./handlers');
module.exports = resolve;

var FALSE = handlers.resolve(new Promise(INTERNAL), false);
var NULL = handlers.resolve(new Promise(INTERNAL), null);
var UNDEFINED = handlers.resolve(new Promise(INTERNAL), void 0);
var ZERO = handlers.resolve(new Promise(INTERNAL), 0);
var EMPTYSTRING = handlers.resolve(new Promise(INTERNAL), '');

function resolve(value) {
  if (value) {
    if (value instanceof Promise) {
      return value;
    }
    return handlers.resolve(new Promise(INTERNAL), value);
  }
  var valueType = typeof value;
  switch (valueType) {
    case 'boolean':
      return FALSE;
    case 'undefined':
      return UNDEFINED;
    case 'object':
      return NULL;
    case 'number':
      return ZERO;
    case 'string':
      return EMPTYSTRING;
  }
}
},{"./INTERNAL":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/INTERNAL.js","./handlers":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/handlers.js","./promise":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/promise.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/resolveThenable.js":[function(require,module,exports){
'use strict';
var handlers = require('./handlers');
var tryCatch = require('./tryCatch');
function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }
  
  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}
exports.safely = safelyResolveThenable;
},{"./handlers":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/handlers.js","./tryCatch":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/tryCatch.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/states.js":[function(require,module,exports){
// Lazy man's symbols for states

exports.REJECTED = ['REJECTED'];
exports.FULFILLED = ['FULFILLED'];
exports.PENDING = ['PENDING'];

},{}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/tryCatch.js":[function(require,module,exports){
'use strict';

module.exports = tryCatch;

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}
},{}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/unwrap.js":[function(require,module,exports){
'use strict';

var immediate = require('immediate');
var handlers = require('./handlers');
module.exports = unwrap;

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}
},{"./handlers":"/home/fiatjaf/comp/trello-browser/node_modules/lie/lib/handlers.js","immediate":"/home/fiatjaf/comp/trello-browser/node_modules/lie/node_modules/immediate/lib/index.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/node_modules/immediate/lib/index.js":[function(require,module,exports){
'use strict';
var types = [
  require('./nextTick'),
  require('./mutation.js'),
  require('./messageChannel'),
  require('./stateChange'),
  require('./timeout')
];
var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}
var scheduleDrain;
var i = -1;
var len = types.length;
while (++ i < len) {
  if (types[i] && types[i].test && types[i].test()) {
    scheduleDrain = types[i].install(nextTick);
    break;
  }
}
module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}
},{"./messageChannel":"/home/fiatjaf/comp/trello-browser/node_modules/lie/node_modules/immediate/lib/messageChannel.js","./mutation.js":"/home/fiatjaf/comp/trello-browser/node_modules/lie/node_modules/immediate/lib/mutation.js","./nextTick":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/browser-resolve/empty.js","./stateChange":"/home/fiatjaf/comp/trello-browser/node_modules/lie/node_modules/immediate/lib/stateChange.js","./timeout":"/home/fiatjaf/comp/trello-browser/node_modules/lie/node_modules/immediate/lib/timeout.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/node_modules/immediate/lib/messageChannel.js":[function(require,module,exports){
(function (global){
'use strict';

exports.test = function () {
  if (global.setImmediate) {
    // we can only get here in IE10
    // which doesn't handel postMessage well
    return false;
  }
  return typeof global.MessageChannel !== 'undefined';
};

exports.install = function (func) {
  var channel = new global.MessageChannel();
  channel.port1.onmessage = func;
  return function () {
    channel.port2.postMessage(0);
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/node_modules/immediate/lib/mutation.js":[function(require,module,exports){
(function (global){
'use strict';
//based off rsvp https://github.com/tildeio/rsvp.js
//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

exports.test = function () {
  return Mutation;
};

exports.install = function (handle) {
  var called = 0;
  var observer = new Mutation(handle);
  var element = global.document.createTextNode('');
  observer.observe(element, {
    characterData: true
  });
  return function () {
    element.data = (called = ++called % 2);
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/node_modules/immediate/lib/stateChange.js":[function(require,module,exports){
(function (global){
'use strict';

exports.test = function () {
  return 'document' in global && 'onreadystatechange' in global.document.createElement('script');
};

exports.install = function (handle) {
  return function () {

    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
    var scriptEl = global.document.createElement('script');
    scriptEl.onreadystatechange = function () {
      handle();

      scriptEl.onreadystatechange = null;
      scriptEl.parentNode.removeChild(scriptEl);
      scriptEl = null;
    };
    global.document.documentElement.appendChild(scriptEl);

    return handle;
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/home/fiatjaf/comp/trello-browser/node_modules/lie/node_modules/immediate/lib/timeout.js":[function(require,module,exports){
'use strict';
exports.test = function () {
  return true;
};

exports.install = function (t) {
  return function () {
    setTimeout(t, 0);
  };
};
},{}],"/home/fiatjaf/comp/trello-browser/node_modules/superagent-promise/index.js":[function(require,module,exports){
/**
 * Promise wrapper for superagent
 */

function wrap(superagent, Promise) {
  /**
   * Request object similar to superagent.Request, but with end() returning
   * a promise.
   */
  function PromiseRequest() {
    superagent.Request.apply(this, arguments);
  }

  // Inherit form superagent.Request
  PromiseRequest.prototype = Object.create(superagent.Request.prototype);

  /** Send request and get a promise that `end` was emitted */
  PromiseRequest.prototype.end = function(cb) {
    var _end = superagent.Request.prototype.end;
    var self = this;

    return new Promise(function(accept, reject) {
      _end.call(self, function(err, value) {
        if (cb) {
          cb(err, value);
        }

        if (err) {
          reject(err);
        } else {
          accept(value);
        }
      });
    });
  };

  /** Provide a more promise-y interface */
  PromiseRequest.prototype.then = function(resolve, reject) {
    var _end = superagent.Request.prototype.end;
    var self = this;

    return new Promise(function(accept, reject) {
      _end.call(self, function(err, value) {
        if (err) {
          reject(err);
        } else {
          accept(value);
        }
      });
    }).then(resolve, reject);
  };

  /**
   * Request builder with same interface as superagent.
   * It is convenient to import this as `request` in place of superagent.
   */
  var request = function(method, url) {
    return new PromiseRequest(method, url);
  };

  /** Helper for making a get request */
  request.get = function(url, data) {
    var req = request('GET', url);
    if (data) {
      req.query(data);
    }
    return req;
  };

  /** Helper for making a head request */
  request.head = function(url, data) {
    var req = request('HEAD', url);
    if (data) {
      req.send(data);
    }
    return req;
  };

  /** Helper for making a delete request */
  request.del = function(url) {
    return request('DELETE', url);
  };

  /** Helper for making a patch request */
  request.patch = function(url, data) {
    var req = request('PATCH', url);
    if (data) {
      req.send(data);
    }
    return req;
  };

  /** Helper for making a post request */
  request.post = function(url, data) {
    var req = request('POST', url);
    if (data) {
      req.send(data);
    }
    return req;
  };

  /** Helper for making a put request */
  request.put = function(url, data) {
    var req = request('PUT', url);
    if (data) {
      req.send(data);
    }
    return req;
  };

  // Export the request builder
  return request;
}

module.exports = wrap;

},{}],"/home/fiatjaf/comp/trello-browser/node_modules/superagent/lib/client.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');

/**
 * Root reference for iframes.
 */

var root = 'undefined' == typeof window
  ? (this || self)
  : window;

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return obj === Object(obj);
}

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(obj[key]));
    }
  }
  return pairs.join('&');
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  Emitter.call(this);
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {};
  this._header = {};
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      return self.callback(err);
    }

    self.emit('response', res);

    if (err) {
      return self.callback(err, res);
    }

    if (res.status >= 200 && res.status < 300) {
      return self.callback(err, res);
    }

    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
    new_err.original = err;
    new_err.response = res;
    new_err.status = res.status;

    self.callback(err || new_err, res);
  });
}

/**
 * Mixin `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Allow for extension
 */

Request.prototype.use = function(fn) {
  fn(this);
  return this;
}

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.timeout = function(ms){
  this._timeout = ms;
  return this;
};

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.clearTimeout = function(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set header `field` to `val`, or multiple fields with one object.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Get case-insensitive header `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api private
 */

Request.prototype.getHeader = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass){
  var str = btoa(user + ':' + pass);
  this.set('Authorization', 'Basic ' + str);
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.field = function(name, val){
  if (!this._formData) this._formData = new root.FormData();
  this._formData.append(name, val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  if (!this._formData) this._formData = new root.FormData();
  this._formData.append(field, file, filename);
  return this;
};

/**
 * Send `data`, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // querystring
 *       request.get('/search')
 *         .end(callback)
 *
 *       // multiple data "writes"
 *       request.get('/search')
 *         .send({ search: 'query' })
 *         .send({ range: '1..5' })
 *         .send({ order: 'desc' })
 *         .end(callback)
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"})
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this.getHeader('Content-Type');

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this.getHeader('Content-Type');
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || isHost(data)) return this;
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');
  err.crossDomain = true;
  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self.timeoutError();
      if (self.aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(e){
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    xhr.onprogress = handleProgress;
  }
  try {
    if (xhr.upload && this.hasListeners('progress')) {
      xhr.upload.onprogress = handleProgress;
    }
  } catch(e) {
    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
    // Reported here:
    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  xhr.open(this.method, this.url, true);

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var serialize = request.serialize[this.getHeader('Content-Type')];
    if (serialize) {
      data = serialize(data);
    } else if (typeof data == 'object') {
      data = JSON.stringify(data);
    }
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  // send stuff
  this.emit('request', this);
  xhr.send(data);
  return this;
};

/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(method, url) {
  // callback
  if ('function' == typeof url) {
    return new Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new Request('GET', method);
  }

  return new Request(method, url);
}

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.del = function(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * Expose `request`.
 */

module.exports = request;

},{"emitter":"/home/fiatjaf/comp/trello-browser/node_modules/superagent/node_modules/component-emitter/index.js","reduce":"/home/fiatjaf/comp/trello-browser/node_modules/superagent/node_modules/reduce-component/index.js"}],"/home/fiatjaf/comp/trello-browser/node_modules/superagent/node_modules/component-emitter/index.js":[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],"/home/fiatjaf/comp/trello-browser/node_modules/superagent/node_modules/reduce-component/index.js":[function(require,module,exports){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
},{}],"/home/fiatjaf/comp/trello-browser/node_modules/xtend/immutable.js":[function(require,module,exports){
module.exports = extend

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/app.coffee":[function(require,module,exports){
var Lockr, Promise, Router, State, Trello, container, haiku, handlers, router, superagent, tl, trello;

Promise = require('lie');

Trello = require('trello-browser');

Router = require('routerjs');

Lockr = require('lockr');

tl = require('talio');

haiku = require('haikunator');

superagent = Trello.superagent;

trello = new Trello('ac61d8974aa86dd25f9597fa651a2ed8');

humane.timeout = 2500;

humane.waitForMove = false;

humane.clickToClose = true;

humane.info = humane.spawn({
  addnCls: 'humane-flatty-info',
  timeout: 5000
});

humane.error = humane.spawn({
  addnCls: 'humane-flatty-error',
  timeout: 4000
});

humane.success = humane.spawn({
  addnCls: 'humane-flatty-success',
  timeout: 2500
});

router = new Router();

State = tl.StateFactory({
  next: null,
  user: {
    id: '',
    boards: []
  },
  board: {
    id: '',
    cards: []
  },
  card: {
    id: '',
    attachments: []
  },
  attachment: {
    name: '',
    id: '',
    url: '',
    mimeType: '',
    content: ''
  }
});

handlers = {
  change: function(State, data) {
    var key;
    key = Object.keys(data)[0];
    return State.change(key, data[key]);
  },
  onLogged: function(State) {
    return Promise.resolve().then(function() {
      humane.log('You are connected to Trello.');
      return trello.get("/1/tokens/" + trello.token + "/member", {
        fields: 'username,id'
      });
    }).then(function(user) {
      var remove;
      humane.info("Welcome, <b>" + user.username + "</b>.");
      State.silentlyUpdate('user', user);
      document.body.insertBefore(document.getElementById('app'), document.querySelector('footer'));
      remove = document.querySelector('body > article');
      document.body.removeChild(remove);
      if (State.get('next')) {
        return router.redirect(State.get('next'));
      } else if (location.hash.slice(0, 7) === '#/login') {
        return router.redirect("#/user/" + (State.get('user.id')));
      }
    })["catch"](function() {
      return Lockr.set('token', null);
    })["catch"](console.log.bind(console));
  },
  login: function(State) {
    return Promise.resolve().then(function() {
      if (!State.get('user.id')) {
        return trello.auth({
          name: 'Trello Attachment Editor',
          scope: {
            read: true,
            write: true
          },
          expiration: '1day'
        });
      }
    }).then((function(_this) {
      return function() {
        var now;
        now = new Date;
        Lockr.set('token', trello.token);
        Lockr.set('token-expires', now.setMinutes(now.getMinutes() + 60 * 15));
        return _this.onLogged(State);
      };
    })(this))["catch"](console.log.bind(console));
  },
  listBoards: function(State) {
    return Promise.resolve().then((function(_this) {
      return function() {
        if (!State.get('user.id')) {
          return router.redirect('#/login');
        }
      };
    })(this)).then(function() {
      return trello.get("/1/members/" + (State.get('user.id')) + "/boards", {
        filter: 'open',
        fields: 'id,name'
      });
    }).then(function(boards) {
      return State.change('user.boards', boards);
    })["catch"](console.log.bind(console));
  },
  listCards: function(State) {
    return Promise.resolve().then((function(_this) {
      return function() {
        if (!State.get('user.boards').length) {
          return _this.listBoards(State);
        }
      };
    })(this)).then(function() {
      return trello.get("/1/boards/" + (State.get('board.id')) + "/cards", {
        filter: 'open',
        fields: 'id,name'
      });
    }).then(function(cards) {
      return State.change('board.cards', cards);
    })["catch"](console.log.bind(console));
  },
  listAttachments: function(State) {
    return Promise.resolve().then((function(_this) {
      return function() {
        if (!State.get('board.cards').length) {
          return _this.listCards(State);
        }
      };
    })(this)).then(function() {
      return trello.get("/1/cards/" + (State.get('card.id')) + "/attachments", {
        fields: 'id,name,url,mimeType'
      });
    }).then(function(attachments) {
      if (attachments.length > 0) {
        State.silentlyUpdate('attachment.new', false);
      }
      return State.change('card.attachments', attachments);
    })["catch"](console.log.bind(console));
  },
  fetchAttachment: function(State) {
    return Promise.resolve().then((function(_this) {
      return function() {
        if (!State.get('card.attachments').length) {
          return _this.listAttachments(State);
        }
      };
    })(this)).then(function() {
      var attachment, i, len, ref;
      if (State.get('attachment.new')) {
        return;
      } else {
        ref = State.get('card.attachments');
        for (i = 0, len = ref.length; i < len; i++) {
          attachment = ref[i];
          if (attachment.name === State.get('attachment.name')) {
            State.silentlyUpdate('attachment', attachment);
            return Promise.resolve().then(function() {
              return superagent.get('//cors-anywhere.herokuapp.com/' + attachment.url);
            }).then(function(res) {
              return State.change('attachment.content', res.text);
            });
          }
        }
      }
      throw new Error('no attachment found with that name.');
    })["catch"]((function(_this) {
      return function() {
        return _this.newAttachment(State, {
          name: State.get('attachment.name')
        });
      };
    })(this))["catch"](console.log.bind(console));
  },
  newAttachment: function(State, presets) {
    var kind, name;
    name = presets.name, kind = presets.kind;
    if (!name) {
      if (!kind) {
        kind = 'txt';
      }
      name = haiku({
        tokenLength: 0,
        delimiter: ''
      }) + '.' + kind;
    }
    State.change({
      attachment: {
        id: null,
        name: name,
        content: (function() {
          switch (name.split('.').slice(-1)[0]) {
            case 'js':
              return 'document.addEventListener("DOMContentLoaded", function () {\n\n})';
            case 'css':
              return 'body > main article {\n\n}';
            default:
              return '# new attachment';
          }
        })(),
        "new": true
      }
    });
    return router.redirect("#/b/" + (State.get('board.id')) + "/c/" + (State.get('card.id')) + "/a/" + name);
  },
  sendTextAsFile: function(State, data) {
    return Promise.resolve().then(function() {
      return trello.post("/1/cards/" + (State.get('card.id')) + "/attachments", {
        mimeType: '',
        name: State.get('attachment.name'),
        file: data['attachment.content']
      });
    }).then((function(_this) {
      return function(res) {
        humane.success("attachment <b>" + (State.get('attachment.name')) + "</b> saved on Trello.");
        if (State.get('attachment.id')) {
          _this.deleteAttachmentFromTrello(State, {
            card: State.get('card.id'),
            attachment: State.get('attachment.id')
          });
        }
        return State.change('attachment.id', res.id);
      };
    })(this)).then(handlers.listAttachments.bind(handlers, State))["catch"](console.log.bind(console));
  },
  deleteAttachment: function(State, which) {
    return Promise.resolve().then((function(_this) {
      return function() {
        return _this.deleteAttachmentFromTrello(State, which);
      };
    })(this)).then(function() {
      return humane.success("Attachment deleted.");
    }).then(handlers.listAttachments.bind(handlers, State))["catch"](console.log.bind(console));
  },
  deleteAttachmentFromTrello: function(State, which) {
    var attachment, card;
    card = which.card, attachment = which.attachment;
    return trello["delete"]("/1/cards/" + card + "/attachments/" + attachment)["catch"](console.log.bind(console));
  }
};

Promise.resolve('starting...').then(function() {
  var cardReferred;
  console.log('referrer:', document.referrer);
  if (-1 !== document.referrer.indexOf('https://trello.com/')) {
    cardReferred = document.referrer.split('/')[4];
    return trello.get("/1/cards/" + cardReferred, {
      fields: 'id,idBoard'
    });
  }
}).then(function(card) {
  if (card) {
    location.hash = "#/b/" + card.idBoard + "/c/" + card.id;
  }
  if ((new Date) < Lockr.get('token-expires')) {
    trello.token = Lockr.get('token');
    return handlers.onLogged(State);
  }
}).then(function() {
  return router.before(function(req, next) {
    if (State.get('user.id') && req.href.slice(0, 7) === '#/login') {
      router.redirect("#/user/" + (State.get('user.id')));
      return;
    } else if (!State.get('user.id') && req.href.slice(0, 7) !== '#/login') {
      router.redirect('#/login?next=' + req.href);
      return;
    } else if (req.get('next')) {
      State.silentlyUpdate('next', req.get('next'));
    }
    return next();
  }).addRoute('#/login', function(req) {
    return console.log('logging in');
  }).addRoute('#/user/:user', function(req) {
    if (req.params.user !== State.get('user.id')) {
      State.silentlyUpdate('user', {
        boards: []
      });
      return router.redirect('#/login');
    } else {
      State.silentlyUpdate('user.id', req.params.user);
      return handlers.listBoards(State);
    }
  }).addRoute('#/b/:board', function(req) {
    State.silentlyUpdate('board.id', req.params.board);
    State.silentlyUpdate('card', {
      attachments: []
    });
    State.silentlyUpdate('attachment', {});
    return handlers.listCards(State);
  }).addRoute('#/b/:board/c/:card', function(req) {
    State.silentlyUpdate('board.id', req.params.board);
    State.silentlyUpdate('card.id', req.params.card);
    State.silentlyUpdate('attachment', {});
    return handlers.listAttachments(State);
  }).addRoute('#/b/:board/c/:card/a/:attachmentName', function(req) {
    State.silentlyUpdate('board.id', req.params.board);
    State.silentlyUpdate('card.id', req.params.card);
    State.silentlyUpdate('attachment', {
      name: req.params.attachmentName
    });
    return handlers.fetchAttachment(State);
  }).errors(404, function(err, href) {
    console.log('no route', err, href);
    return router.redirect('#/login');
  }).run(location.hash);
});

container = document.getElementById('app');

tl.run(container, require('./vrender-main'), handlers, State);


},{"./vrender-main":"/home/fiatjaf/comp/wft/attachments-edit/vrender-main.coffee","haikunator":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/haikunator/index.js","lie":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/lie/lib/index.js","lockr":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/lockr/lockr.js","routerjs":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/routerjs/dist/router.min.js","talio":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/index.coffee","trello-browser":"/home/fiatjaf/comp/trello-browser/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/assert/assert.js":[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/util/util.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/browser-resolve/empty.js":[function(require,module,exports){

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/util/util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/util/support/isBufferBrowser.js","_process":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/process/browser.js","inherits":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/haikunator/index.js":[function(require,module,exports){
var adjs = [
  "autumn", "hidden", "bitter", "misty", "silent", "empty", "dry", "dark",
  "summer", "icy", "delicate", "quiet", "white", "cool", "spring", "winter",
  "patient", "twilight", "dawn", "crimson", "wispy", "weathered", "blue",
  "billowing", "broken", "cold", "damp", "falling", "frosty", "green",
  "long", "late", "lingering", "bold", "little", "morning", "muddy", "old",
  "red", "rough", "still", "small", "sparkling", "throbbing", "shy",
  "wandering", "withered", "wild", "black", "young", "holy", "solitary",
  "fragrant", "aged", "snowy", "proud", "floral", "restless", "divine",
  "polished", "ancient", "purple", "lively", "nameless", "lucky", "odd", "tiny",
  "free", "dry", "yellow", "orange", "gentle", "tight", "super", "royal", "broad",
  "steep", "flat", "square", "round", "mute", "noisy", "hushy", "raspy", "soft",
  "shrill", "rapid", "sweet", "curly", "calm", "jolly", "fancy", "plain", "shinny"
];
var nouns = [
  "waterfall", "river", "breeze", "moon", "rain", "wind", "sea", "morning",
  "snow", "lake", "sunset", "pine", "shadow", "leaf", "dawn", "glitter",
  "forest", "hill", "cloud", "meadow", "sun", "glade", "bird", "brook",
  "butterfly", "bush", "dew", "dust", "field", "fire", "flower", "firefly",
  "feather", "grass", "haze", "mountain", "night", "pond", "darkness",
  "snowflake", "silence", "sound", "sky", "shape", "surf", "thunder",
  "violet", "water", "wildflower", "wave", "water", "resonance", "sun",
  "wood", "dream", "cherry", "tree", "fog", "frost", "voice", "paper",
  "frog", "smoke", "star", "atom", "band", "bar", "base", "block", "boat",
  "term", "credit", "art", "fashion", "truth", "disk", "math", "unit", "cell",
  "scene", "heart", "recipe", "union", "limit", "bread", "toast", "bonus",
  "lab", "mud", "mode", "poetry", "tooth", "hall", "king", "queen", "lion", "tiger",
  "penguin", "kiwi", "cake", "mouse", "rice", "coke", "hola", "salad", "hat"
];

function extend(obj) {
  Array.prototype.slice.call(arguments, 1).forEach(function (source) {
    var prop;
    if (source) {
      for (prop in source) {
        obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

var haikunator = function (opt) {
  var i, adj, noun, sections, defaults, token = "";

  defaults = {
    delimiter: "-",
    tokenLength: 4,
    tokenHex: false,
    tokenChars: "0123456789"
  };

  opt = extend(defaults, opt);

  if (opt.tokenHex === true) {
    opt.tokenChars = "0123456789abcdef";
  }

  adj = adjs[Math.floor(Math.random() * adjs.length)];
  noun = nouns[Math.floor(Math.random() * nouns.length)];

  for (i = 0; i < opt.tokenLength; i++) {
    token += opt.tokenChars.charAt(Math.floor(Math.random() * opt.tokenChars.length));
  }

  sections = [adj, noun, token];
  return sections.filter(function (e) { return e === 0 || e; }).join(opt.delimiter);
};

module.exports = haikunator;
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/lie/lib/index.js":[function(require,module,exports){
'use strict';
var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && typeof obj === 'object' && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

exports.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

exports.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

exports.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

exports.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/lie/node_modules/immediate/lib/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/lie/node_modules/immediate/lib/index.js":[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/lockr/lockr.js":[function(require,module,exports){
(function(root, factory) {

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = factory(root, exports);
    }
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], function(exports) {
      root.Lockr = factory(root, exports);
    });
  } else {
    root.Lockr = factory(root, {});
  }

}(this, function(root, Lockr) {
  'use strict';

  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(elt /*, from*/)
    {
      var len = this.length >>> 0;

      var from = Number(arguments[1]) || 0;
      from = (from < 0)
      ? Math.ceil(from)
      : Math.floor(from);
      if (from < 0)
        from += len;

      for (; from < len; from++)
      {
        if (from in this &&
            this[from] === elt)
          return from;
      }
      return -1;
    };
  }

  Lockr.prefix = "";

  Lockr._getPrefixedKey = function(key, options) {
    options = options || {};

    if (options.noPrefix) {
      return key;
    } else {
      return this.prefix + key;
    }

  };

  Lockr.set = function (key, value, options) {
    var query_key = this._getPrefixedKey(key, options);

    try {
      localStorage.setItem(query_key, JSON.stringify({"data": value}));
    } catch (e) {
      if (console) console.warn("Lockr didn't successfully save the '{"+ key +": "+ value +"}' pair, because the localStorage is full.");
    }
  };

  Lockr.get = function (key, missing, options) {
    var query_key = this._getPrefixedKey(key, options),
        value;

    try {
      value = JSON.parse(localStorage.getItem(query_key));
    } catch (e) {
      value = null;
    }
    if(value === null)
      return missing;
    else
      return (value.data || missing);
  };

  Lockr.sadd = function(key, value, options) {
    var query_key = this._getPrefixedKey(key, options),
        json;

    var values = Lockr.smembers(key);

    if (values.indexOf(value) > -1) {
      return null;
    }

    try {
      values.push(value);
      json = JSON.stringify({"data": values});
      localStorage.setItem(query_key, json);
    } catch (e) {
      console.log(e);
      if (console) console.warn("Lockr didn't successfully add the "+ value +" to "+ key +" set, because the localStorage is full.");
    }
  };

  Lockr.smembers = function(key, options) {
    var query_key = this._getPrefixedKey(key, options),
        value;

    try {
      value = JSON.parse(localStorage.getItem(query_key));
    } catch (e) {
      value = null;
    }

    if (value === null)
      return [];
    else
      return (value.data || []);
  };

  Lockr.sismember = function(key, value, options) {
    var query_key = this._getPrefixedKey(key, options);

    return Lockr.smembers(key).indexOf(value) > -1;
  };

  Lockr.getAll = function () {
    var keys = Object.keys(localStorage);

    return keys.map(function (key) {
      return Lockr.get(key);
    });
  };

  Lockr.srem = function(key, value, options) {
    var query_key = this._getPrefixedKey(key, options),
        json,
        index;

    var values = Lockr.smembers(key, value);

    index = values.indexOf(value);

    if (index > -1)
      values.splice(index, 1);

    json = JSON.stringify({"data": values});

    try {
      localStorage.setItem(query_key, json);
    } catch (e) {
      if (console) console.warn("Lockr couldn't remove the "+ value +" from the set "+ key);
    }
  };

  Lockr.rm =  function (key) {
    localStorage.removeItem(key);
  };

  Lockr.flush = function () {
    localStorage.clear();
  };
  return Lockr;

}));

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/routerjs/dist/router.min.js":[function(require,module,exports){
/*!
router
@version: 1.0.0
@description: Lightweight and powerful router for javascript applications
@author: Fabrizio Ruggeri <fabrizio.ruggeri@gmail.com>
@website: http://ramielcreations.com/projects/router-js/
@license GPL2
*/
!function(a,b){"undefined"!=typeof module?module.exports=b():"function"==typeof define&&"object"==typeof define.amd?define(b):this[a]=b()}("Router",function(){function a(a,b){a.addEventListener?a.addEventListener("hashchange",b,!1):a.attachEvent&&a.attachEvent("hashchange",b)}function b(a,b){a.removeEventListener?a.removeEventListener("hashchange",b,!1):a.detachEvent&&a.detachEvent("hashchange",b)}function c(){for(var a=1;a<arguments.length;a++)for(var b in arguments[a])arguments[a].hasOwnProperty(b)&&(arguments[0][b]=arguments[a][b]);return arguments[0]}Function.prototype.bind||(Function.prototype.bind=function(a){var b=this,c=Array.prototype.slice.call(arguments);return a=c.shift(),function(){return b.apply(a,c.concat(Array.prototype.slice.call(arguments)))}});var d="([^/\\?]+)",e=/:([\w\d]+)/g,f=/\/\*(?!\*)/,g="/([^/\\?]+)",h=/\*{2}/,i="(.*?)\\??",j=/\/*$/,k=function(a){this.href=a,this.params,this.query,this.splat,this.hasNext=!1};k.prototype.get=function(a,b){return this.params&&void 0!==this.params[a]?this.params[a]:this.query&&void 0!==this.query[a]?this.query[a]:void 0!==b?b:void 0};var l=function(b){this._options=c({ignorecase:!0},b),this._routes=[],this._befores=[],this._errors={_:function(a,b,c){console&&console.warn&&console.warn("Router.js : "+c)},_404:function(a,b){console&&console.warn&&console.warn("404! Unmatched route for url "+b)},_500:function(a,b){if(!console||!console.error)throw new Error("500");console.error("500! Internal error route for url "+b)}},this._paused=!1,this._hasChangeHandler=this._onHashChange.bind(this),a(window,this._hasChangeHandler)};return l.prototype._onHashChange=function(){return this._paused||this._route(this._extractFragment(window.location.href)),!0},l.prototype._extractFragment=function(a){var b=a.indexOf("#");return b>=0?a.substring(b):"#/"},l.prototype._throwsRouteError=function(a,b,c){return this._errors["_"+a]instanceof Function?this._errors["_"+a](b,c,a):this._errors._(b,c,a),!1},l.prototype._buildRequestObject=function(a,b,c,d){if(!a)throw new Error("Unable to compile request object");var e=new k(a);b&&(e.params=b);var f=a.split("?");if(2==f.length){var g=null,h=f[1].split("&");e.query={};for(var i=0,j=h.length;j>i;i++)g=h[i].split("="),e.query[decodeURI(g[0])]=decodeURI(g[1].replace(/\+/g,"%20"));e.query}return c&&c.length>0&&(e.splats=c),d===!0&&(e.hasNext=!0),e},l.prototype._followRoute=function(a,b,c){var d,e=c.splice(0,1),f=this._routes[e],g=b.match(f.path),h={},i=[];if(!f)return this._throwsRouteError(500,new Error("Internal error"),a);for(var j=0,k=f.paramNames.length;k>j;j++)h[f.paramNames[j]]=g[j+1];if(j+=1,g&&j<g.length)for(var l=j;l<g.length;l++)i.push(g[l]);var m=0!==c.length,n=function(b,c,d,e){return function(e,f,g){return e||f?f?this._throwsRouteError(g||500,f,a):void this._followRoute(b,c,d):this._throwsRouteError(500,'Cannot call "next" without an error if request.hasNext is false',a)}.bind(this,e)}.bind(this)(a,b,c,m);d=this._buildRequestObject(a,h,i,m),f.routeAction(d,n)},l.prototype._routeBefores=function(a,b,c,d,e){var f;if(a.length>0){var g=a.splice(0,1);g=g[0],f=function(b,f){return b?this._throwsRouteError(f||500,b,c):void this._routeBefores(a,g,c,d,e)}.bind(this)}else f=function(a,b){return a?this._throwsRouteError(b||500,a,c):void this._followRoute(c,d,e)}.bind(this);b(this._buildRequestObject(c,null,null,!0),f)},l.prototype._route=function(a){var b,c="",d=this._befores.slice(),e=[],f=a;if(0===f.length)return!0;f=f.replace(j,""),b=f.split("?")[0].replace(j,"");for(var g in this._routes)this._routes.hasOwnProperty(g)&&(c=this._routes[g],c.path.test(b)&&e.push(g));if(!(e.length>0))return this._throwsRouteError(404,null,a);if(d.length>0){var h=d.splice(0,1);h=h[0],this._routeBefores(d,h,a,f,e)}else this._followRoute(a,f,e)},l.prototype.pause=function(){return this._paused=!0,this},l.prototype.play=function(a){return a="undefined"==typeof a?!1:a,this._paused=!1,a&&this._route(this._extractFragment(window.location.href)),this},l.prototype.setLocation=function(a){return window.history.pushState(null,"",a),this},l.prototype.redirect=function(a){return this.setLocation(a),this._paused||this._route(this._extractFragment(a)),this},l.prototype.addRoute=l.prototype.add=l.prototype.route=l.prototype.get=function(a,b){var c,k=this._options.ignorecase?"i":"",l=[];if("string"==typeof a){for(a=a.replace(j,"");null!==(c=e.exec(a));)l.push(c[1]);a=new RegExp(a.replace(e,d).replace(f,g).replace(h,i)+"(?:\\?.+)?$",k)}return this._routes.push({path:a,paramNames:l,routeAction:b}),this},l.prototype.before=function(a){return this._befores.push(a),this},l.prototype.errors=function(a,b){if(isNaN(a))throw new Error("Invalid code for routes error handling");if(!(b instanceof Function))throw new Error("Invalid callback for routes error handling");return a="_"+a,this._errors[a]=b,this},l.prototype.run=function(a){return a||(a=this._extractFragment(window.location.href)),a=0===a.indexOf("#")?a:"#"+a,this.redirect(a),this},l.prototype.destroy=function(){return b(window,this._hasChangeHandler),this},l});

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/index.coffee":[function(require,module,exports){
var Delegator, InvalidUpdateInRender, TalioState, TypedError, extend, immupdate, mainloop, raf;

Delegator = require('dom-delegator');

extend = require('xtend');

immupdate = require('immupdate');

module.exports['virtual-dom'] = require('virtual-dom');

module.exports.h = require('virtual-dom/h');

module.exports.sendEvent = require('value-event/event');

module.exports.sendValue = require('value-event/value');

module.exports.sendClick = require('value-event/click');

module.exports.sendSubmit = require('value-event/submit');

module.exports.sendChange = require('value-event/change');

module.exports.sendKey = require('value-event/key');

module.exports.sendDetail = (require('value-event/base-event'))(function(ev, broadcast) {
  var data, detail;
  detail = ev._rawEvent.detail;
  data = extend(detail, this.data);
  return broadcast(data);
});

TalioState = (function() {
  TalioState.prototype.type = 'TalioState';

  function TalioState(state1) {
    this.state = state1;
  }

  TalioState.prototype.silentlyUpdate = function() {
    var u;
    u = immupdate.bind(this, this.state);
    return this.state = u.apply(this, arguments);
  };

  TalioState.prototype.change = function() {
    this.silentlyUpdate.apply(this, arguments);
    if (this.cb) {
      return this.cb(this.state);
    }
  };

  TalioState.prototype.subscribe = function(cb) {
    return this.cb = cb;
  };

  TalioState.prototype.itself = function() {
    return this.state;
  };

  TalioState.prototype.get = function(prop) {
    var degree, e, i, len, ref, ret;
    ret = this.state;
    try {
      ref = prop.split('.');
      for (i = 0, len = ref.length; i < len; i++) {
        degree = ref[i];
        ret = ret[degree];
      }
    } catch (_error) {
      e = _error;
    }
    return ret;
  };

  return TalioState;

})();

module.exports.StateFactory = function(dict) {
  return new TalioState(dict);
};

raf = require('raf');

TypedError = require('error/typed');

InvalidUpdateInRender = TypedError({
  type: 'talio.invalid.update.in-render',
  message: 'talio: Unexpected update occurred in loop.\n' + 'We are currently rendering a view, ' + 'you can\'t change state right now.\n' + 'The diff is: {stringDiff}.\n' + 'SUGGESTED FIX: find the state mutation in your view ' + 'or rendering function and remove it.\n' + 'The view should not have any side effects.\n',
  diff: null,
  stringDiff: null
});

mainloop = function(initialState, view, channels, opts) {
  var create, currentState, diff, inRenderingTransaction, patch, redraw, redrawScheduled, target, tree, update;
  opts = opts || {};
  currentState = initialState;
  create = opts.create;
  diff = opts.diff;
  patch = opts.patch;
  redrawScheduled = false;
  tree = opts.initialTree || view(currentState, channels);
  target = opts.target || create(tree, opts);
  inRenderingTransaction = false;
  currentState = null;
  update = function(state) {
    if (inRenderingTransaction) {
      throw InvalidUpdateInRender({
        diff: state._diff,
        stringDiff: JSON.stringify(state._diff)
      });
    }
    if (currentState === null && !redrawScheduled) {
      redrawScheduled = true;
      raf(redraw);
    }
    currentState = state;
  };
  redraw = function() {
    var e, newTree, patches;
    redrawScheduled = false;
    if (currentState === null) {
      return;
    }
    inRenderingTransaction = true;
    try {
      newTree = view(currentState, channels);
    } catch (_error) {
      e = _error;
      console.error("We had a problem while rendering the tree with the following state:", currentState);
      console.debug("Aborting the render.");
      inRenderingTransaction = false;
      newTree = tree;
      console.debug(e.stack);
    }
    if (opts.createOnly) {
      inRenderingTransaction = false;
      create(newTree, opts);
    } else {
      patches = diff(tree, newTree, opts);
      inRenderingTransaction = false;
      target = patch(target, patches, opts);
    }
    tree = newTree;
    currentState = null;
  };
  return {
    target: target,
    update: update
  };
};

module.exports.Delegator = Delegator;

module.exports.delegator = Delegator();

module.exports.run = function(domnode, vrender, handlers, BaseState) {
  var channels, createChannel, theloop;
  if (!BaseState || BaseState.type !== 'TalioState') {
    BaseState = new TalioState({});
  }
  createChannel = function(acc, name) {
    acc[name] = Delegator.allocateHandle(handlers[name].bind(handlers, BaseState));
    return acc;
  };
  channels = Object.keys(handlers).reduce(createChannel, {});
  theloop = mainloop(BaseState.itself(), vrender, channels, {
    diff: require('virtual-dom/vtree/diff'),
    patch: require('virtual-dom/vdom/patch'),
    create: require('virtual-dom/vdom/create-element')
  });
  domnode.appendChild(theloop.target);
  return BaseState.subscribe(function(state) {
    return theloop.update(state);
  });
};


},{"dom-delegator":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/index.js","error/typed":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/error/typed.js","immupdate":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/immupdate/immupdate.js","raf":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/raf/index.js","value-event/base-event":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/base-event.js","value-event/change":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/change.js","value-event/click":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/click.js","value-event/event":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/event.js","value-event/key":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/key.js","value-event/submit":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/submit.js","value-event/value":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/value.js","virtual-dom":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/index.js","virtual-dom/h":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/h.js","virtual-dom/vdom/create-element":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/create-element.js","virtual-dom/vdom/patch":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/patch.js","virtual-dom/vtree/diff":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vtree/diff.js","xtend":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/xtend/immutable.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/add-event.js":[function(require,module,exports){
var EvStore = require("ev-store")

module.exports = addEvent

function addEvent(target, type, handler) {
    var events = EvStore(target)
    var event = events[type]

    if (!event) {
        events[type] = handler
    } else if (Array.isArray(event)) {
        if (event.indexOf(handler) === -1) {
            event.push(handler)
        }
    } else if (event !== handler) {
        events[type] = [event, handler]
    }
}

},{"ev-store":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/dom-delegator.js":[function(require,module,exports){
var globalDocument = require("global/document")
var EvStore = require("ev-store")
var createStore = require("weakmap-shim/create-store")

var addEvent = require("./add-event.js")
var removeEvent = require("./remove-event.js")
var ProxyEvent = require("./proxy-event.js")

var HANDLER_STORE = createStore()

module.exports = DOMDelegator

function DOMDelegator(document) {
    if (!(this instanceof DOMDelegator)) {
        return new DOMDelegator(document);
    }

    document = document || globalDocument

    this.target = document.documentElement
    this.events = {}
    this.rawEventListeners = {}
    this.globalListeners = {}
}

DOMDelegator.prototype.addEventListener = addEvent
DOMDelegator.prototype.removeEventListener = removeEvent

DOMDelegator.allocateHandle =
    function allocateHandle(func) {
        var handle = new Handle()

        HANDLER_STORE(handle).func = func;

        return handle
    }

DOMDelegator.transformHandle =
    function transformHandle(handle, broadcast) {
        var func = HANDLER_STORE(handle).func

        return this.allocateHandle(function (ev) {
            broadcast(ev, func);
        })
    }

DOMDelegator.prototype.addGlobalEventListener =
    function addGlobalEventListener(eventName, fn) {
        var listeners = this.globalListeners[eventName] || [];
        if (listeners.indexOf(fn) === -1) {
            listeners.push(fn)
        }

        this.globalListeners[eventName] = listeners;
    }

DOMDelegator.prototype.removeGlobalEventListener =
    function removeGlobalEventListener(eventName, fn) {
        var listeners = this.globalListeners[eventName] || [];

        var index = listeners.indexOf(fn)
        if (index !== -1) {
            listeners.splice(index, 1)
        }
    }

DOMDelegator.prototype.listenTo = function listenTo(eventName) {
    if (!(eventName in this.events)) {
        this.events[eventName] = 0;
    }

    this.events[eventName]++;

    if (this.events[eventName] !== 1) {
        return
    }

    var listener = this.rawEventListeners[eventName]
    if (!listener) {
        listener = this.rawEventListeners[eventName] =
            createHandler(eventName, this)
    }

    this.target.addEventListener(eventName, listener, true)
}

DOMDelegator.prototype.unlistenTo = function unlistenTo(eventName) {
    if (!(eventName in this.events)) {
        this.events[eventName] = 0;
    }

    if (this.events[eventName] === 0) {
        throw new Error("already unlistened to event.");
    }

    this.events[eventName]--;

    if (this.events[eventName] !== 0) {
        return
    }

    var listener = this.rawEventListeners[eventName]

    if (!listener) {
        throw new Error("dom-delegator#unlistenTo: cannot " +
            "unlisten to " + eventName)
    }

    this.target.removeEventListener(eventName, listener, true)
}

function createHandler(eventName, delegator) {
    var globalListeners = delegator.globalListeners;
    var delegatorTarget = delegator.target;

    return handler

    function handler(ev) {
        var globalHandlers = globalListeners[eventName] || []

        if (globalHandlers.length > 0) {
            var globalEvent = new ProxyEvent(ev);
            globalEvent.currentTarget = delegatorTarget;
            callListeners(globalHandlers, globalEvent)
        }

        findAndInvokeListeners(ev.target, ev, eventName)
    }
}

function findAndInvokeListeners(elem, ev, eventName) {
    var listener = getListener(elem, eventName)

    if (listener && listener.handlers.length > 0) {
        var listenerEvent = new ProxyEvent(ev);
        listenerEvent.currentTarget = listener.currentTarget
        callListeners(listener.handlers, listenerEvent)

        if (listenerEvent._bubbles) {
            var nextTarget = listener.currentTarget.parentNode
            findAndInvokeListeners(nextTarget, ev, eventName)
        }
    }
}

function getListener(target, type) {
    // terminate recursion if parent is `null`
    if (target === null || typeof target === "undefined") {
        return null
    }

    var events = EvStore(target)
    // fetch list of handler fns for this event
    var handler = events[type]
    var allHandler = events.event

    if (!handler && !allHandler) {
        return getListener(target.parentNode, type)
    }

    var handlers = [].concat(handler || [], allHandler || [])
    return new Listener(target, handlers)
}

function callListeners(handlers, ev) {
    handlers.forEach(function (handler) {
        if (typeof handler === "function") {
            handler(ev)
        } else if (typeof handler.handleEvent === "function") {
            handler.handleEvent(ev)
        } else if (handler.type === "dom-delegator-handle") {
            HANDLER_STORE(handler).func(ev)
        } else {
            throw new Error("dom-delegator: unknown handler " +
                "found: " + JSON.stringify(handlers));
        }
    })
}

function Listener(target, handlers) {
    this.currentTarget = target
    this.handlers = handlers
}

function Handle() {
    this.type = "dom-delegator-handle"
}

},{"./add-event.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/add-event.js","./proxy-event.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/proxy-event.js","./remove-event.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/remove-event.js","ev-store":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/index.js","global/document":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/global/document.js","weakmap-shim/create-store":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/weakmap-shim/create-store.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/index.js":[function(require,module,exports){
var Individual = require("individual")
var cuid = require("cuid")
var globalDocument = require("global/document")

var DOMDelegator = require("./dom-delegator.js")

var versionKey = "13"
var cacheKey = "__DOM_DELEGATOR_CACHE@" + versionKey
var cacheTokenKey = "__DOM_DELEGATOR_CACHE_TOKEN@" + versionKey
var delegatorCache = Individual(cacheKey, {
    delegators: {}
})
var commonEvents = [
    "blur", "change", "click",  "contextmenu", "dblclick",
    "error","focus", "focusin", "focusout", "input", "keydown",
    "keypress", "keyup", "load", "mousedown", "mouseup",
    "resize", "select", "submit", "touchcancel",
    "touchend", "touchstart", "unload"
]

/*  Delegator is a thin wrapper around a singleton `DOMDelegator`
        instance.

    Only one DOMDelegator should exist because we do not want
        duplicate event listeners bound to the DOM.

    `Delegator` will also `listenTo()` all events unless
        every caller opts out of it
*/
module.exports = Delegator

function Delegator(opts) {
    opts = opts || {}
    var document = opts.document || globalDocument

    var cacheKey = document[cacheTokenKey]

    if (!cacheKey) {
        cacheKey =
            document[cacheTokenKey] = cuid()
    }

    var delegator = delegatorCache.delegators[cacheKey]

    if (!delegator) {
        delegator = delegatorCache.delegators[cacheKey] =
            new DOMDelegator(document)
    }

    if (opts.defaultEvents !== false) {
        for (var i = 0; i < commonEvents.length; i++) {
            delegator.listenTo(commonEvents[i])
        }
    }

    return delegator
}

Delegator.allocateHandle = DOMDelegator.allocateHandle;
Delegator.transformHandle = DOMDelegator.transformHandle;

},{"./dom-delegator.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/dom-delegator.js","cuid":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/cuid/dist/browser-cuid.js","global/document":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/global/document.js","individual":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/individual/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/cuid/dist/browser-cuid.js":[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 * 
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

/*global window, navigator, document, require, process, module */
(function (app) {
  'use strict';
  var namespace = 'cuid',
    c = 0,
    blockSize = 4,
    base = 36,
    discreteValues = Math.pow(base, blockSize),

    pad = function pad(num, size) {
      var s = "000000000" + num;
      return s.substr(s.length-size);
    },

    randomBlock = function randomBlock() {
      return pad((Math.random() *
            discreteValues << 0)
            .toString(base), blockSize);
    },

    safeCounter = function () {
      c = (c < discreteValues) ? c : 0;
      c++; // this is not subliminal
      return c - 1;
    },

    api = function cuid() {
      // Starting with a lowercase letter makes
      // it HTML element ID friendly.
      var letter = 'c', // hard-coded allows for sequential access

        // timestamp
        // warning: this exposes the exact date and time
        // that the uid was created.
        timestamp = (new Date().getTime()).toString(base),

        // Prevent same-machine collisions.
        counter,

        // A few chars to generate distinct ids for different
        // clients (so different computers are far less
        // likely to generate the same id)
        fingerprint = api.fingerprint(),

        // Grab some more chars from Math.random()
        random = randomBlock() + randomBlock();

        counter = pad(safeCounter().toString(base), blockSize);

      return  (letter + timestamp + counter + fingerprint + random);
    };

  api.slug = function slug() {
    var date = new Date().getTime().toString(36),
      counter,
      print = api.fingerprint().slice(0,1) +
        api.fingerprint().slice(-1),
      random = randomBlock().slice(-2);

      counter = safeCounter().toString(36).slice(-4);

    return date.slice(-2) + 
      counter + print + random;
  };

  api.globalCount = function globalCount() {
    // We want to cache the results of this
    var cache = (function calc() {
        var i,
          count = 0;

        for (i in window) {
          count++;
        }

        return count;
      }());

    api.globalCount = function () { return cache; };
    return cache;
  };

  api.fingerprint = function browserPrint() {
    return pad((navigator.mimeTypes.length +
      navigator.userAgent.length).toString(36) +
      api.globalCount().toString(36), 4);
  };

  // don't change anything from here down.
  if (app.register) {
    app.register(namespace, api);
  } else if (typeof module !== 'undefined') {
    module.exports = api;
  } else {
    app[namespace] = api;
  }

}(this.applitude || this));

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/index.js":[function(require,module,exports){
'use strict';

var OneVersionConstraint = require('individual/one-version');

var MY_VERSION = '7';
OneVersionConstraint('ev-store', MY_VERSION);

var hashKey = '__EV_STORE_KEY@' + MY_VERSION;

module.exports = EvStore;

function EvStore(elem) {
    var hash = elem[hashKey];

    if (!hash) {
        hash = elem[hashKey] = {};
    }

    return hash;
}

},{"individual/one-version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/node_modules/individual/one-version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/node_modules/individual/index.js":[function(require,module,exports){
(function (global){
'use strict';

/*global window, global*/

var root = typeof window !== 'undefined' ?
    window : typeof global !== 'undefined' ?
    global : {};

module.exports = Individual;

function Individual(key, value) {
    if (key in root) {
        return root[key];
    }

    root[key] = value;

    return value;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/node_modules/individual/one-version.js":[function(require,module,exports){
'use strict';

var Individual = require('./index.js');

module.exports = OneVersion;

function OneVersion(moduleName, version, defaultValue) {
    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;
    var enforceKey = key + '_ENFORCE_SINGLETON';

    var versionValue = Individual(enforceKey, version);

    if (versionValue !== version) {
        throw new Error('Can only have one copy of ' +
            moduleName + '.\n' +
            'You already have version ' + versionValue +
            ' installed.\n' +
            'This means you cannot install version ' + version);
    }

    return Individual(key, defaultValue);
}

},{"./index.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/node_modules/individual/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/global/document.js":[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"min-document":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/browser-resolve/empty.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/individual/index.js":[function(require,module,exports){
(function (global){
var root = typeof window !== 'undefined' ?
    window : typeof global !== 'undefined' ?
    global : {};

module.exports = Individual

function Individual(key, value) {
    if (root[key]) {
        return root[key]
    }

    Object.defineProperty(root, key, {
        value: value
        , configurable: true
    })

    return value
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/inherits/inherits_browser.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/weakmap-shim/create-store.js":[function(require,module,exports){
var hiddenStore = require('./hidden-store.js');

module.exports = createStore;

function createStore() {
    var key = {};

    return function (obj) {
        if ((typeof obj !== 'object' || obj === null) &&
            typeof obj !== 'function'
        ) {
            throw new Error('Weakmap-shim: Key must be object')
        }

        var store = obj.valueOf(key);
        return store && store.identity === key ?
            store : hiddenStore(obj, key);
    };
}

},{"./hidden-store.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/weakmap-shim/hidden-store.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/weakmap-shim/hidden-store.js":[function(require,module,exports){
module.exports = hiddenStore;

function hiddenStore(obj, key) {
    var store = { identity: key };
    var valueOf = obj.valueOf;

    Object.defineProperty(obj, "valueOf", {
        value: function (value) {
            return value !== key ?
                valueOf.apply(this, arguments) : store;
        },
        writable: true
    });

    return store;
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/proxy-event.js":[function(require,module,exports){
var inherits = require("inherits")

var ALL_PROPS = [
    "altKey", "bubbles", "cancelable", "ctrlKey",
    "eventPhase", "metaKey", "relatedTarget", "shiftKey",
    "target", "timeStamp", "type", "view", "which"
]
var KEY_PROPS = ["char", "charCode", "key", "keyCode"]
var MOUSE_PROPS = [
    "button", "buttons", "clientX", "clientY", "layerX",
    "layerY", "offsetX", "offsetY", "pageX", "pageY",
    "screenX", "screenY", "toElement"
]

var rkeyEvent = /^key|input/
var rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/

module.exports = ProxyEvent

function ProxyEvent(ev) {
    if (!(this instanceof ProxyEvent)) {
        return new ProxyEvent(ev)
    }

    if (rkeyEvent.test(ev.type)) {
        return new KeyEvent(ev)
    } else if (rmouseEvent.test(ev.type)) {
        return new MouseEvent(ev)
    }

    for (var i = 0; i < ALL_PROPS.length; i++) {
        var propKey = ALL_PROPS[i]
        this[propKey] = ev[propKey]
    }

    this._rawEvent = ev
    this._bubbles = false;
}

ProxyEvent.prototype.preventDefault = function () {
    this._rawEvent.preventDefault()
}

ProxyEvent.prototype.startPropagation = function () {
    this._bubbles = true;
}

function MouseEvent(ev) {
    for (var i = 0; i < ALL_PROPS.length; i++) {
        var propKey = ALL_PROPS[i]
        this[propKey] = ev[propKey]
    }

    for (var j = 0; j < MOUSE_PROPS.length; j++) {
        var mousePropKey = MOUSE_PROPS[j]
        this[mousePropKey] = ev[mousePropKey]
    }

    this._rawEvent = ev
}

inherits(MouseEvent, ProxyEvent)

function KeyEvent(ev) {
    for (var i = 0; i < ALL_PROPS.length; i++) {
        var propKey = ALL_PROPS[i]
        this[propKey] = ev[propKey]
    }

    for (var j = 0; j < KEY_PROPS.length; j++) {
        var keyPropKey = KEY_PROPS[j]
        this[keyPropKey] = ev[keyPropKey]
    }

    this._rawEvent = ev
}

inherits(KeyEvent, ProxyEvent)

},{"inherits":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/inherits/inherits_browser.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/remove-event.js":[function(require,module,exports){
var EvStore = require("ev-store")

module.exports = removeEvent

function removeEvent(target, type, handler) {
    var events = EvStore(target)
    var event = events[type]

    if (!event) {
        return
    } else if (Array.isArray(event)) {
        var index = event.indexOf(handler)
        if (index !== -1) {
            event.splice(index, 1)
        }
    } else if (event === handler) {
        events[type] = null
    }
}

},{"ev-store":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/error/node_modules/string-template/index.js":[function(require,module,exports){
var nargs = /\{([0-9a-zA-Z]+)\}/g
var slice = Array.prototype.slice

module.exports = template

function template(string) {
    var args

    if (arguments.length === 2 && typeof arguments[1] === "object") {
        args = arguments[1]
    } else {
        args = slice.call(arguments, 1)
    }

    if (!args || !args.hasOwnProperty) {
        args = {}
    }

    return string.replace(nargs, function replaceArg(match, i, index) {
        var result

        if (string[index - 1] === "{" &&
            string[index + match.length] === "}") {
            return i
        } else {
            result = args.hasOwnProperty(i) ? args[i] : null
            if (result === null || result === undefined) {
                return ""
            }

            return result
        }
    })
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/error/typed.js":[function(require,module,exports){
'use strict';

var template = require('string-template');
var extend = require('xtend/mutable');
var assert = require('assert');

var isWordBoundary = /[_.-](\w|$)/g;

module.exports = TypedError;

function TypedError(args) {
    assert(args, 'TypedError: must specify options');
    assert(args.type, 'TypedError: must specify options.type');
    assert(args.message, 'TypedError: must specify options.message');

    assert(!has(args, 'fullType'),
        'TypedError: fullType field is reserved');

    var message = args.message;
    if (args.type && !args.name) {
        var errorName = camelCase(args.type) + 'Error';
        args.name = errorName[0].toUpperCase() + errorName.substr(1);
    }

    extend(createError, args);
    createError._name = args.name;

    return createError;

    function createError(opts) {
        var result = new Error();

        Object.defineProperty(result, 'type', {
            value: result.type,
            enumerable: true,
            writable: true,
            configurable: true
        });

        var options = extend({}, args, opts);
        if (!options.fullType) {
            options.fullType = options.type;
        }

        extend(result, options);
        if (opts && opts.message) {
            result.message = template(opts.message, options);
        } else if (message) {
            result.message = template(message, options);
        }

        return result;
    }
}

function camelCase(str) {
    return str.replace(isWordBoundary, upperCase);
}

function upperCase(_, x) {
    return x.toUpperCase();
}

function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

},{"assert":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/assert/assert.js","string-template":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/error/node_modules/string-template/index.js","xtend/mutable":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/xtend/mutable.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/immupdate/immupdate.js":[function(require,module,exports){

function update(host, spec) {
  // Single path string update like: update(obj, 'path1.path2.name', 'John');
  if (arguments.length == 3) {
    var value = arguments[2];
    var paths = spec.split('.');
    var specObj = {};
    var currentObj = specObj;
    paths.forEach(function(path, index) {
      if (index == paths.length - 1) currentObj[path] = value;
      else currentObj[path] = currentObj = {};
    });
    spec = specObj;
  }

  // If any of the branches of an object changed, then than object changed too: clone it.
  // The type of the copy is inferred.
  var copy = host
    ? Array.isArray(host) ? host.slice() : clone(host)
    : Array.isArray(spec) ? [] : {};

  for (var key in spec) {
    var specValue = spec[key];

    if (specValue == DELETE) {
      Array.isArray(copy) ? copy.splice(key, 1) : delete copy[key];
    }
    // The spec continues deeper
    else if (isObject(specValue)) {
      copy[key] = update(copy[key], specValue);
    }
    // Leaf update
    else {
      var newValue = (typeof specValue == 'function')
        ? specValue(copy[key])
        : specValue;

      copy[key] = newValue;
    }
  }

  return copy;
}

function clone(obj) {
  var result = {};
  Object.keys(obj).forEach(function(key) { result[key] = obj[key] });
  return result;
}

function isObject(x) { return x && typeof x == 'object' && !Array.isArray(x) }


var DELETE = update.DELETE = {};

module.exports = update;
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/raf/index.js":[function(require,module,exports){
var now = require('performance-now')
  , global = typeof window === 'undefined' ? {} : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = global['request' + suffix]
  , caf = global['cancel' + suffix] || global['cancelRequest' + suffix]

for(var i = 0; i < vendors.length && !raf; i++) {
  raf = global[vendors[i] + 'Request' + suffix]
  caf = global[vendors[i] + 'Cancel' + suffix]
      || global[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(global, fn)
}
module.exports.cancel = function() {
  caf.apply(global, arguments)
}

},{"performance-now":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/raf/node_modules/performance-now/lib/performance-now.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/raf/node_modules/performance-now/lib/performance-now.js":[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))
},{"_process":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/process/browser.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/base-event.js":[function(require,module,exports){
var Delegator = require('dom-delegator')

module.exports = BaseEvent

function BaseEvent(lambda) {
    return EventHandler;

    function EventHandler(fn, data, opts) {
        var handler = {
            fn: fn,
            data: data !== undefined ? data : {},
            opts: opts || {},
            handleEvent: handleEvent
        }

        if (fn && fn.type === 'dom-delegator-handle') {
            return Delegator.transformHandle(fn,
                handleLambda.bind(handler))
        }

        return handler;
    }

    function handleLambda(ev, broadcast) {
        if (this.opts.startPropagation && ev.startPropagation) {
            ev.startPropagation();
        }

        return lambda.call(this, ev, broadcast)
    }

    function handleEvent(ev) {
        var self = this

        if (self.opts.startPropagation && ev.startPropagation) {
            ev.startPropagation()
        }

        lambda.call(self, ev, broadcast)

        function broadcast(value) {
            if (typeof self.fn === 'function') {
                self.fn(value)
            } else {
                self.fn.write(value)
            }
        }
    }
}

},{"dom-delegator":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/change.js":[function(require,module,exports){
var extend = require('xtend')
var getFormData = require('form-data-set/element')

var BaseEvent = require('./base-event.js')

var VALID_CHANGE = ['checkbox', 'file', 'select-multiple', 'select-one'];
var VALID_INPUT = ['color', 'date', 'datetime', 'datetime-local', 'email',
    'month', 'number', 'password', 'range', 'search', 'tel', 'text', 'time',
    'url', 'week'];

module.exports = BaseEvent(changeLambda);

function changeLambda(ev, broadcast) {
    var target = ev.target

    var isValid =
        (ev.type === 'input' && VALID_INPUT.indexOf(target.type) !== -1) ||
        (ev.type === 'change' && VALID_CHANGE.indexOf(target.type) !== -1);

    if (!isValid) {
        if (ev.startPropagation) {
            ev.startPropagation()
        }
        return
    }

    var value = getFormData(ev.currentTarget)
    var data = extend(value, this.data)

    broadcast(data)
}

},{"./base-event.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/base-event.js","form-data-set/element":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/form-data-set/element.js","xtend":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/xtend/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/click.js":[function(require,module,exports){
var BaseEvent = require('./base-event.js');

module.exports = BaseEvent(clickLambda);

function clickLambda(ev, broadcast) {
    var opts = this.opts;

    if (!opts.ctrl && ev.ctrlKey) {
        return;
    }

    if (!opts.meta && ev.metaKey) {
        return;
    }

    if (!opts.rightClick && ev.which === 2) {
        return;
    }

    if (this.opts.preventDefault && ev.preventDefault) {
        ev.preventDefault();
    }

    broadcast(this.data);
}

},{"./base-event.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/base-event.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/event.js":[function(require,module,exports){
var BaseEvent = require('./base-event.js');

module.exports = BaseEvent(eventLambda);

function eventLambda(ev, broadcast) {
    broadcast(this.data);
}

},{"./base-event.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/base-event.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/key.js":[function(require,module,exports){
var BaseEvent = require('./base-event.js');

module.exports = BaseEvent(keyLambda);

function keyLambda(ev, broadcast) {
    var key = this.opts.key;

    if (ev.keyCode === key) {
        broadcast(this.data);
    }
}

},{"./base-event.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/base-event.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/dom-walk/index.js":[function(require,module,exports){
var slice = Array.prototype.slice

module.exports = iterativelyWalk

function iterativelyWalk(nodes, cb) {
    if (!('length' in nodes)) {
        nodes = [nodes]
    }
    
    nodes = slice.call(nodes)

    while(nodes.length) {
        var node = nodes.shift(),
            ret = cb(node)

        if (ret) {
            return ret
        }

        if (node.childNodes && node.childNodes.length) {
            nodes = slice.call(node.childNodes).concat(nodes)
        }
    }
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/form-data-set/element.js":[function(require,module,exports){
var walk = require('dom-walk')

var FormData = require('./index.js')

module.exports = getFormData

function buildElems(rootElem) {
    var hash = {}
    if (rootElem.name) {
    	hash[rootElem.name] = rootElem
    }

    walk(rootElem, function (child) {
        if (child.name) {
            hash[child.name] = child
        }
    })


    return hash
}

function getFormData(rootElem) {
    var elements = buildElems(rootElem)

    return FormData(elements)
}

},{"./index.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/form-data-set/index.js","dom-walk":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/dom-walk/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/form-data-set/index.js":[function(require,module,exports){
/*jshint maxcomplexity: 10*/

module.exports = FormData

//TODO: Massive spec: http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#constructing-form-data-set
function FormData(elements) {
    return Object.keys(elements).reduce(function (acc, key) {
        var elem = elements[key]

        acc[key] = valueOfElement(elem)

        return acc
    }, {})
}

function valueOfElement(elem) {
    if (typeof elem === "function") {
        return elem()
    } else if (containsRadio(elem)) {
        var elems = toList(elem)
        var checked = elems.filter(function (elem) {
            return elem.checked
        })[0] || null

        return checked ? checked.value : null
    } else if (Array.isArray(elem)) {
        return elem.map(valueOfElement).filter(filterNull)
    } else if (elem.tagName === undefined && elem.nodeType === undefined) {
        return FormData(elem)
    } else if (elem.tagName === "INPUT" && isChecked(elem)) {
        if (elem.hasAttribute("value")) {
            return elem.checked ? elem.value : null
        } else {
            return elem.checked
        }
    } else if (elem.tagName === "INPUT") {
        return elem.value
    } else if (elem.tagName === "TEXTAREA") {
        return elem.value
    } else if (elem.tagName === "SELECT") {
        return elem.value
    }
}

function isChecked(elem) {
    return elem.type === "checkbox" || elem.type === "radio"
}

function containsRadio(value) {
    if (value.tagName || value.nodeType) {
        return false
    }

    var elems = toList(value)

    return elems.some(function (elem) {
        return elem.tagName === "INPUT" && elem.type === "radio"
    })
}

function toList(value) {
    if (Array.isArray(value)) {
        return value
    }

    return Object.keys(value).map(prop, value)
}

function prop(x) {
    return this[x]
}

function filterNull(val) {
    return val !== null
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/xtend/has-keys.js":[function(require,module,exports){
module.exports = hasKeys

function hasKeys(source) {
    return source !== null &&
        (typeof source === "object" ||
        typeof source === "function")
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/xtend/index.js":[function(require,module,exports){
var hasKeys = require("./has-keys")

module.exports = extend

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        if (!hasKeys(source)) {
            continue
        }

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{"./has-keys":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/xtend/has-keys.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/submit.js":[function(require,module,exports){
var extend = require('xtend')
var getFormData = require('form-data-set/element')

var BaseEvent = require('./base-event.js');

var ENTER = 13

module.exports = BaseEvent(submitLambda);

function submitLambda(ev, broadcast) {
    var target = ev.target

    var isValid =
        (ev.type === 'submit' && target.tagName === 'FORM') ||
        (ev.type === 'click' && target.tagName === 'BUTTON') ||
        (ev.type === 'click' && target.type === 'submit') ||
        (
            (target.type === 'text') &&
            (ev.keyCode === ENTER && ev.type === 'keydown')
        )

    if (!isValid) {
        if (ev.startPropagation) {
            ev.startPropagation()
        }
        return
    }

    var value = getFormData(ev.currentTarget)
    var data = extend(value, this.data)

    if (ev.preventDefault) {
        ev.preventDefault();
    }

    broadcast(data);
}

},{"./base-event.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/base-event.js","form-data-set/element":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/form-data-set/element.js","xtend":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/xtend/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/value.js":[function(require,module,exports){
var extend = require('xtend')
var getFormData = require('form-data-set/element')

var BaseEvent = require('./base-event.js');

module.exports = BaseEvent(valueLambda);

function valueLambda(ev, broadcast) {
    var value = getFormData(ev.currentTarget)
    var data = extend(value, this.data)

    broadcast(data);
}

},{"./base-event.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/base-event.js","form-data-set/element":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/form-data-set/element.js","xtend":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/value-event/node_modules/xtend/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/create-element.js":[function(require,module,exports){
var createElement = require("./vdom/create-element.js")

module.exports = createElement

},{"./vdom/create-element.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/create-element.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/diff.js":[function(require,module,exports){
var diff = require("./vtree/diff.js")

module.exports = diff

},{"./vtree/diff.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vtree/diff.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/h.js":[function(require,module,exports){
var h = require("./virtual-hyperscript/index.js")

module.exports = h

},{"./virtual-hyperscript/index.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/index.js":[function(require,module,exports){
var diff = require("./diff.js")
var patch = require("./patch.js")
var h = require("./h.js")
var create = require("./create-element.js")
var VNode = require('./vnode/vnode.js')
var VText = require('./vnode/vtext.js')

module.exports = {
    diff: diff,
    patch: patch,
    h: h,
    create: create,
    VNode: VNode,
    VText: VText
}

},{"./create-element.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/create-element.js","./diff.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/diff.js","./h.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/h.js","./patch.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/patch.js","./vnode/vnode.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vnode.js","./vnode/vtext.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vtext.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/browser-split/index.js":[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/ev-store/index.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/index.js"][0].apply(exports,arguments)
},{"individual/one-version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/one-version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/index.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/node_modules/individual/index.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/one-version.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/node_modules/individual/one-version.js"][0].apply(exports,arguments)
},{"./index.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/global/document.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/global/document.js"][0].apply(exports,arguments)
},{"min-document":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/browserify/node_modules/browser-resolve/empty.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/is-object/index.js":[function(require,module,exports){
"use strict";

module.exports = function isObject(x) {
	return typeof x === "object" && x !== null;
};

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/x-is-array/index.js":[function(require,module,exports){
var nativeIsArray = Array.isArray
var toString = Object.prototype.toString

module.exports = nativeIsArray || isArray

function isArray(obj) {
    return toString.call(obj) === "[object Array]"
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/patch.js":[function(require,module,exports){
var patch = require("./vdom/patch.js")

module.exports = patch

},{"./vdom/patch.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/patch.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/apply-properties.js":[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook.js")

module.exports = applyProperties

function applyProperties(node, props, previous) {
    for (var propName in props) {
        var propValue = props[propName]

        if (propValue === undefined) {
            removeProperty(node, propName, propValue, previous);
        } else if (isHook(propValue)) {
            removeProperty(node, propName, propValue, previous)
            if (propValue.hook) {
                propValue.hook(node,
                    propName,
                    previous ? previous[propName] : undefined)
            }
        } else {
            if (isObject(propValue)) {
                patchObject(node, props, previous, propName, propValue);
            } else {
                node[propName] = propValue
            }
        }
    }
}

function removeProperty(node, propName, propValue, previous) {
    if (previous) {
        var previousValue = previous[propName]

        if (!isHook(previousValue)) {
            if (propName === "attributes") {
                for (var attrName in previousValue) {
                    node.removeAttribute(attrName)
                }
            } else if (propName === "style") {
                for (var i in previousValue) {
                    node.style[i] = ""
                }
            } else if (typeof previousValue === "string") {
                node[propName] = ""
            } else {
                node[propName] = null
            }
        } else if (previousValue.unhook) {
            previousValue.unhook(node, propName, propValue)
        }
    }
}

function patchObject(node, props, previous, propName, propValue) {
    var previousValue = previous ? previous[propName] : undefined

    // Set attributes
    if (propName === "attributes") {
        for (var attrName in propValue) {
            var attrValue = propValue[attrName]

            if (attrValue === undefined) {
                node.removeAttribute(attrName)
            } else {
                node.setAttribute(attrName, attrValue)
            }
        }

        return
    }

    if(previousValue && isObject(previousValue) &&
        getPrototype(previousValue) !== getPrototype(propValue)) {
        node[propName] = propValue
        return
    }

    if (!isObject(node[propName])) {
        node[propName] = {}
    }

    var replacer = propName === "style" ? "" : undefined

    for (var k in propValue) {
        var value = propValue[k]
        node[propName][k] = (value === undefined) ? replacer : value
    }
}

function getPrototype(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

},{"../vnode/is-vhook.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vhook.js","is-object":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/is-object/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/create-element.js":[function(require,module,exports){
var document = require("global/document")

var applyProperties = require("./apply-properties")

var isVNode = require("../vnode/is-vnode.js")
var isVText = require("../vnode/is-vtext.js")
var isWidget = require("../vnode/is-widget.js")
var handleThunk = require("../vnode/handle-thunk.js")

module.exports = createElement

function createElement(vnode, opts) {
    var doc = opts ? opts.document || document : document
    var warn = opts ? opts.warn : null

    vnode = handleThunk(vnode).a

    if (isWidget(vnode)) {
        return vnode.init()
    } else if (isVText(vnode)) {
        return doc.createTextNode(vnode.text)
    } else if (!isVNode(vnode)) {
        if (warn) {
            warn("Item is not a valid virtual dom node", vnode)
        }
        return null
    }

    var node = (vnode.namespace === null) ?
        doc.createElement(vnode.tagName) :
        doc.createElementNS(vnode.namespace, vnode.tagName)

    var props = vnode.properties
    applyProperties(node, props)

    var children = vnode.children

    for (var i = 0; i < children.length; i++) {
        var childNode = createElement(children[i], opts)
        if (childNode) {
            node.appendChild(childNode)
        }
    }

    return node
}

},{"../vnode/handle-thunk.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/handle-thunk.js","../vnode/is-vnode.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vnode.js","../vnode/is-vtext.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vtext.js","../vnode/is-widget.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-widget.js","./apply-properties":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/apply-properties.js","global/document":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/global/document.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/dom-index.js":[function(require,module,exports){
// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
// We don't want to read all of the DOM nodes in the tree so we use
// the in-order tree indexing to eliminate recursion down certain branches.
// We only recurse into a DOM node if we know that it contains a child of
// interest.

var noChild = {}

module.exports = domIndex

function domIndex(rootNode, tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending)
        return recurse(rootNode, tree, indices, nodes, 0)
    }
}

function recurse(rootNode, tree, indices, nodes, rootIndex) {
    nodes = nodes || {}


    if (rootNode) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode
        }

        var vChildren = tree.children

        if (vChildren) {

            var childNodes = rootNode.childNodes

            for (var i = 0; i < tree.children.length; i++) {
                rootIndex += 1

                var vChild = vChildren[i] || noChild
                var nextIndex = rootIndex + (vChild.count || 0)

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)
                }

                rootIndex = nextIndex
            }
        }
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0
    var maxIndex = indices.length - 1
    var currentIndex
    var currentItem

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0
        currentItem = indices[currentIndex]

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/patch-op.js":[function(require,module,exports){
var applyProperties = require("./apply-properties")

var isWidget = require("../vnode/is-widget.js")
var VPatch = require("../vnode/vpatch.js")

var updateWidget = require("./update-widget")

module.exports = applyPatch

function applyPatch(vpatch, domNode, renderOptions) {
    var type = vpatch.type
    var vNode = vpatch.vNode
    var patch = vpatch.patch

    switch (type) {
        case VPatch.REMOVE:
            return removeNode(domNode, vNode)
        case VPatch.INSERT:
            return insertNode(domNode, patch, renderOptions)
        case VPatch.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions)
        case VPatch.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions)
        case VPatch.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions)
        case VPatch.ORDER:
            reorderChildren(domNode, patch)
            return domNode
        case VPatch.PROPS:
            applyProperties(domNode, patch, vNode.properties)
            return domNode
        case VPatch.THUNK:
            return replaceRoot(domNode,
                renderOptions.patch(domNode, patch, renderOptions))
        default:
            return domNode
    }
}

function removeNode(domNode, vNode) {
    var parentNode = domNode.parentNode

    if (parentNode) {
        parentNode.removeChild(domNode)
    }

    destroyWidget(domNode, vNode);

    return null
}

function insertNode(parentNode, vNode, renderOptions) {
    var newNode = renderOptions.render(vNode, renderOptions)

    if (parentNode) {
        parentNode.appendChild(newNode)
    }

    return parentNode
}

function stringPatch(domNode, leftVNode, vText, renderOptions) {
    var newNode

    if (domNode.nodeType === 3) {
        domNode.replaceData(0, domNode.length, vText.text)
        newNode = domNode
    } else {
        var parentNode = domNode.parentNode
        newNode = renderOptions.render(vText, renderOptions)

        if (parentNode && newNode !== domNode) {
            parentNode.replaceChild(newNode, domNode)
        }
    }

    return newNode
}

function widgetPatch(domNode, leftVNode, widget, renderOptions) {
    var updating = updateWidget(leftVNode, widget)
    var newNode

    if (updating) {
        newNode = widget.update(leftVNode, domNode) || domNode
    } else {
        newNode = renderOptions.render(widget, renderOptions)
    }

    var parentNode = domNode.parentNode

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    if (!updating) {
        destroyWidget(domNode, leftVNode)
    }

    return newNode
}

function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
    var parentNode = domNode.parentNode
    var newNode = renderOptions.render(vNode, renderOptions)

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    return newNode
}

function destroyWidget(domNode, w) {
    if (typeof w.destroy === "function" && isWidget(w)) {
        w.destroy(domNode)
    }
}

function reorderChildren(domNode, moves) {
    var childNodes = domNode.childNodes
    var keyMap = {}
    var node
    var remove
    var insert

    for (var i = 0; i < moves.removes.length; i++) {
        remove = moves.removes[i]
        node = childNodes[remove.from]
        if (remove.key) {
            keyMap[remove.key] = node
        }
        domNode.removeChild(node)
    }

    var length = childNodes.length
    for (var j = 0; j < moves.inserts.length; j++) {
        insert = moves.inserts[j]
        node = keyMap[insert.key]
        // this is the weirdest bug i've ever seen in webkit
        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])
    }
}

function replaceRoot(oldRoot, newRoot) {
    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
        oldRoot.parentNode.replaceChild(newRoot, oldRoot)
    }

    return newRoot;
}

},{"../vnode/is-widget.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-widget.js","../vnode/vpatch.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vpatch.js","./apply-properties":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/apply-properties.js","./update-widget":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/update-widget.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/patch.js":[function(require,module,exports){
var document = require("global/document")
var isArray = require("x-is-array")

var render = require("./create-element")
var domIndex = require("./dom-index")
var patchOp = require("./patch-op")
module.exports = patch

function patch(rootNode, patches, renderOptions) {
    renderOptions = renderOptions || {}
    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch
        ? renderOptions.patch
        : patchRecursive
    renderOptions.render = renderOptions.render || render

    return renderOptions.patch(rootNode, patches, renderOptions)
}

function patchRecursive(rootNode, patches, renderOptions) {
    var indices = patchIndices(patches)

    if (indices.length === 0) {
        return rootNode
    }

    var index = domIndex(rootNode, patches.a, indices)
    var ownerDocument = rootNode.ownerDocument

    if (!renderOptions.document && ownerDocument !== document) {
        renderOptions.document = ownerDocument
    }

    for (var i = 0; i < indices.length; i++) {
        var nodeIndex = indices[i]
        rootNode = applyPatch(rootNode,
            index[nodeIndex],
            patches[nodeIndex],
            renderOptions)
    }

    return rootNode
}

function applyPatch(rootNode, domNode, patchList, renderOptions) {
    if (!domNode) {
        return rootNode
    }

    var newNode

    if (isArray(patchList)) {
        for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions)

            if (domNode === rootNode) {
                rootNode = newNode
            }
        }
    } else {
        newNode = patchOp(patchList, domNode, renderOptions)

        if (domNode === rootNode) {
            rootNode = newNode
        }
    }

    return rootNode
}

function patchIndices(patches) {
    var indices = []

    for (var key in patches) {
        if (key !== "a") {
            indices.push(Number(key))
        }
    }

    return indices
}

},{"./create-element":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/create-element.js","./dom-index":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/dom-index.js","./patch-op":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/patch-op.js","global/document":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/global/document.js","x-is-array":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/x-is-array/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vdom/update-widget.js":[function(require,module,exports){
var isWidget = require("../vnode/is-widget.js")

module.exports = updateWidget

function updateWidget(a, b) {
    if (isWidget(a) && isWidget(b)) {
        if ("name" in a && "name" in b) {
            return a.id === b.id
        } else {
            return a.init === b.init
        }
    }

    return false
}

},{"../vnode/is-widget.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-widget.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/hooks/ev-hook.js":[function(require,module,exports){
'use strict';

var EvStore = require('ev-store');

module.exports = EvHook;

function EvHook(value) {
    if (!(this instanceof EvHook)) {
        return new EvHook(value);
    }

    this.value = value;
}

EvHook.prototype.hook = function (node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = this.value;
};

EvHook.prototype.unhook = function(node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = undefined;
};

},{"ev-store":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/ev-store/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js":[function(require,module,exports){
'use strict';

module.exports = SoftSetHook;

function SoftSetHook(value) {
    if (!(this instanceof SoftSetHook)) {
        return new SoftSetHook(value);
    }

    this.value = value;
}

SoftSetHook.prototype.hook = function (node, propertyName) {
    if (node[propertyName] !== this.value) {
        node[propertyName] = this.value;
    }
};

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/index.js":[function(require,module,exports){
'use strict';

var isArray = require('x-is-array');

var VNode = require('../vnode/vnode.js');
var VText = require('../vnode/vtext.js');
var isVNode = require('../vnode/is-vnode');
var isVText = require('../vnode/is-vtext');
var isWidget = require('../vnode/is-widget');
var isHook = require('../vnode/is-vhook');
var isVThunk = require('../vnode/is-thunk');

var parseTag = require('./parse-tag.js');
var softSetHook = require('./hooks/soft-set-hook.js');
var evHook = require('./hooks/ev-hook.js');

module.exports = h;

function h(tagName, properties, children) {
    var childNodes = [];
    var tag, props, key, namespace;

    if (!children && isChildren(properties)) {
        children = properties;
        props = {};
    }

    props = props || properties || {};
    tag = parseTag(tagName, props);

    // support keys
    if (props.hasOwnProperty('key')) {
        key = props.key;
        props.key = undefined;
    }

    // support namespace
    if (props.hasOwnProperty('namespace')) {
        namespace = props.namespace;
        props.namespace = undefined;
    }

    // fix cursor bug
    if (tag === 'INPUT' &&
        !namespace &&
        props.hasOwnProperty('value') &&
        props.value !== undefined &&
        !isHook(props.value)
    ) {
        props.value = softSetHook(props.value);
    }

    transformProperties(props);

    if (children !== undefined && children !== null) {
        addChild(children, childNodes, tag, props);
    }


    return new VNode(tag, props, childNodes, key, namespace);
}

function addChild(c, childNodes, tag, props) {
    if (typeof c === 'string') {
        childNodes.push(new VText(c));
    } else if (typeof c === 'number') {
        childNodes.push(new VText(String(c)));
    } else if (isChild(c)) {
        childNodes.push(c);
    } else if (isArray(c)) {
        for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props);
        }
    } else if (c === null || c === undefined) {
        return;
    } else {
        throw UnexpectedVirtualElement({
            foreignObject: c,
            parentVnode: {
                tagName: tag,
                properties: props
            }
        });
    }
}

function transformProperties(props) {
    for (var propName in props) {
        if (props.hasOwnProperty(propName)) {
            var value = props[propName];

            if (isHook(value)) {
                continue;
            }

            if (propName.substr(0, 3) === 'ev-') {
                // add ev-foo support
                props[propName] = evHook(value);
            }
        }
    }
}

function isChild(x) {
    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);
}

function isChildren(x) {
    return typeof x === 'string' || isArray(x) || isChild(x);
}

function UnexpectedVirtualElement(data) {
    var err = new Error();

    err.type = 'virtual-hyperscript.unexpected.virtual-element';
    err.message = 'Unexpected virtual child passed to h().\n' +
        'Expected a VNode / Vthunk / VWidget / string but:\n' +
        'got:\n' +
        errorString(data.foreignObject) +
        '.\n' +
        'The parent vnode is:\n' +
        errorString(data.parentVnode)
        '\n' +
        'Suggested fix: change your `h(..., [ ... ])` callsite.';
    err.foreignObject = data.foreignObject;
    err.parentVnode = data.parentVnode;

    return err;
}

function errorString(obj) {
    try {
        return JSON.stringify(obj, null, '    ');
    } catch (e) {
        return String(obj);
    }
}

},{"../vnode/is-thunk":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-thunk.js","../vnode/is-vhook":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vhook.js","../vnode/is-vnode":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vnode.js","../vnode/is-vtext":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vtext.js","../vnode/is-widget":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-widget.js","../vnode/vnode.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vnode.js","../vnode/vtext.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vtext.js","./hooks/ev-hook.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/hooks/ev-hook.js","./hooks/soft-set-hook.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js","./parse-tag.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/parse-tag.js","x-is-array":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/x-is-array/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/parse-tag.js":[function(require,module,exports){
'use strict';

var split = require('browser-split');

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

module.exports = parseTag;

function parseTag(tag, props) {
    if (!tag) {
        return 'DIV';
    }

    var noId = !(props.hasOwnProperty('id'));

    var tagParts = split(tag, classIdSplit);
    var tagName = null;

    if (notClassId.test(tagParts[1])) {
        tagName = 'DIV';
    }

    var classes, part, type, i;

    for (i = 0; i < tagParts.length; i++) {
        part = tagParts[i];

        if (!part) {
            continue;
        }

        type = part.charAt(0);

        if (!tagName) {
            tagName = part;
        } else if (type === '.') {
            classes = classes || [];
            classes.push(part.substring(1, part.length));
        } else if (type === '#' && noId) {
            props.id = part.substring(1, part.length);
        }
    }

    if (classes) {
        if (props.className) {
            classes.push(props.className);
        }

        props.className = classes.join(' ');
    }

    return props.namespace ? tagName : tagName.toUpperCase();
}

},{"browser-split":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/browser-split/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/handle-thunk.js":[function(require,module,exports){
var isVNode = require("./is-vnode")
var isVText = require("./is-vtext")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")

module.exports = handleThunk

function handleThunk(a, b) {
    var renderedA = a
    var renderedB = b

    if (isThunk(b)) {
        renderedB = renderThunk(b, a)
    }

    if (isThunk(a)) {
        renderedA = renderThunk(a, null)
    }

    return {
        a: renderedA,
        b: renderedB
    }
}

function renderThunk(thunk, previous) {
    var renderedThunk = thunk.vnode

    if (!renderedThunk) {
        renderedThunk = thunk.vnode = thunk.render(previous)
    }

    if (!(isVNode(renderedThunk) ||
            isVText(renderedThunk) ||
            isWidget(renderedThunk))) {
        throw new Error("thunk did not return a valid node");
    }

    return renderedThunk
}

},{"./is-thunk":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-thunk.js","./is-vnode":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vnode.js","./is-vtext":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vtext.js","./is-widget":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-widget.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-thunk.js":[function(require,module,exports){
module.exports = isThunk

function isThunk(t) {
    return t && t.type === "Thunk"
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vhook.js":[function(require,module,exports){
module.exports = isHook

function isHook(hook) {
    return hook &&
      (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") ||
       typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"))
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vnode.js":[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualNode

function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version
}

},{"./version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vtext.js":[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualText

function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version
}

},{"./version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-widget.js":[function(require,module,exports){
module.exports = isWidget

function isWidget(w) {
    return w && w.type === "Widget"
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/version.js":[function(require,module,exports){
module.exports = "2"

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vnode.js":[function(require,module,exports){
var version = require("./version")
var isVNode = require("./is-vnode")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")
var isVHook = require("./is-vhook")

module.exports = VirtualNode

var noProperties = {}
var noChildren = []

function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName
    this.properties = properties || noProperties
    this.children = children || noChildren
    this.key = key != null ? String(key) : undefined
    this.namespace = (typeof namespace === "string") ? namespace : null

    var count = (children && children.length) || 0
    var descendants = 0
    var hasWidgets = false
    var hasThunks = false
    var descendantHooks = false
    var hooks

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            var property = properties[propName]
            if (isVHook(property) && property.unhook) {
                if (!hooks) {
                    hooks = {}
                }

                hooks[propName] = property
            }
        }
    }

    for (var i = 0; i < count; i++) {
        var child = children[i]
        if (isVNode(child)) {
            descendants += child.count || 0

            if (!hasWidgets && child.hasWidgets) {
                hasWidgets = true
            }

            if (!hasThunks && child.hasThunks) {
                hasThunks = true
            }

            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                descendantHooks = true
            }
        } else if (!hasWidgets && isWidget(child)) {
            if (typeof child.destroy === "function") {
                hasWidgets = true
            }
        } else if (!hasThunks && isThunk(child)) {
            hasThunks = true;
        }
    }

    this.count = count + descendants
    this.hasWidgets = hasWidgets
    this.hasThunks = hasThunks
    this.hooks = hooks
    this.descendantHooks = descendantHooks
}

VirtualNode.prototype.version = version
VirtualNode.prototype.type = "VirtualNode"

},{"./is-thunk":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-thunk.js","./is-vhook":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vhook.js","./is-vnode":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vnode.js","./is-widget":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-widget.js","./version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vpatch.js":[function(require,module,exports){
var version = require("./version")

VirtualPatch.NONE = 0
VirtualPatch.VTEXT = 1
VirtualPatch.VNODE = 2
VirtualPatch.WIDGET = 3
VirtualPatch.PROPS = 4
VirtualPatch.ORDER = 5
VirtualPatch.INSERT = 6
VirtualPatch.REMOVE = 7
VirtualPatch.THUNK = 8

module.exports = VirtualPatch

function VirtualPatch(type, vNode, patch) {
    this.type = Number(type)
    this.vNode = vNode
    this.patch = patch
}

VirtualPatch.prototype.version = version
VirtualPatch.prototype.type = "VirtualPatch"

},{"./version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vtext.js":[function(require,module,exports){
var version = require("./version")

module.exports = VirtualText

function VirtualText(text) {
    this.text = String(text)
}

VirtualText.prototype.version = version
VirtualText.prototype.type = "VirtualText"

},{"./version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vtree/diff-props.js":[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook")

module.exports = diffProps

function diffProps(a, b) {
    var diff

    for (var aKey in a) {
        if (!(aKey in b)) {
            diff = diff || {}
            diff[aKey] = undefined
        }

        var aValue = a[aKey]
        var bValue = b[aKey]

        if (aValue === bValue) {
            continue
        } else if (isObject(aValue) && isObject(bValue)) {
            if (getPrototype(bValue) !== getPrototype(aValue)) {
                diff = diff || {}
                diff[aKey] = bValue
            } else if (isHook(bValue)) {
                 diff = diff || {}
                 diff[aKey] = bValue
            } else {
                var objectDiff = diffProps(aValue, bValue)
                if (objectDiff) {
                    diff = diff || {}
                    diff[aKey] = objectDiff
                }
            }
        } else {
            diff = diff || {}
            diff[aKey] = bValue
        }
    }

    for (var bKey in b) {
        if (!(bKey in a)) {
            diff = diff || {}
            diff[bKey] = b[bKey]
        }
    }

    return diff
}

function getPrototype(value) {
  if (Object.getPrototypeOf) {
    return Object.getPrototypeOf(value)
  } else if (value.__proto__) {
    return value.__proto__
  } else if (value.constructor) {
    return value.constructor.prototype
  }
}

},{"../vnode/is-vhook":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vhook.js","is-object":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/is-object/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vtree/diff.js":[function(require,module,exports){
var isArray = require("x-is-array")

var VPatch = require("../vnode/vpatch")
var isVNode = require("../vnode/is-vnode")
var isVText = require("../vnode/is-vtext")
var isWidget = require("../vnode/is-widget")
var isThunk = require("../vnode/is-thunk")
var handleThunk = require("../vnode/handle-thunk")

var diffProps = require("./diff-props")

module.exports = diff

function diff(a, b) {
    var patch = { a: a }
    walk(a, b, patch, 0)
    return patch
}

function walk(a, b, patch, index) {
    if (a === b) {
        return
    }

    var apply = patch[index]
    var applyClear = false

    if (isThunk(a) || isThunk(b)) {
        thunks(a, b, patch, index)
    } else if (b == null) {

        // If a is a widget we will add a remove patch for it
        // Otherwise any child widgets/hooks must be destroyed.
        // This prevents adding two remove patches for a widget.
        if (!isWidget(a)) {
            clearState(a, patch, index)
            apply = patch[index]
        }

        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))
    } else if (isVNode(b)) {
        if (isVNode(a)) {
            if (a.tagName === b.tagName &&
                a.namespace === b.namespace &&
                a.key === b.key) {
                var propsPatch = diffProps(a.properties, b.properties)
                if (propsPatch) {
                    apply = appendPatch(apply,
                        new VPatch(VPatch.PROPS, a, propsPatch))
                }
                apply = diffChildren(a, b, patch, apply, index)
            } else {
                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
                applyClear = true
            }
        } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
            applyClear = true
        }
    } else if (isVText(b)) {
        if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
            applyClear = true
        } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
        }
    } else if (isWidget(b)) {
        if (!isWidget(a)) {
            applyClear = true
        }

        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))
    }

    if (apply) {
        patch[index] = apply
    }

    if (applyClear) {
        clearState(a, patch, index)
    }
}

function diffChildren(a, b, patch, apply, index) {
    var aChildren = a.children
    var orderedSet = reorder(aChildren, b.children)
    var bChildren = orderedSet.children

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen

    for (var i = 0; i < len; i++) {
        var leftNode = aChildren[i]
        var rightNode = bChildren[i]
        index += 1

        if (!leftNode) {
            if (rightNode) {
                // Excess nodes in b need to be added
                apply = appendPatch(apply,
                    new VPatch(VPatch.INSERT, null, rightNode))
            }
        } else {
            walk(leftNode, rightNode, patch, index)
        }

        if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count
        }
    }

    if (orderedSet.moves) {
        // Reorder nodes last
        apply = appendPatch(apply, new VPatch(
            VPatch.ORDER,
            a,
            orderedSet.moves
        ))
    }

    return apply
}

function clearState(vNode, patch, index) {
    // TODO: Make this a single walk, not two
    unhook(vNode, patch, index)
    destroyWidgets(vNode, patch, index)
}

// Patch records for all destroyed widgets must be added because we need
// a DOM node reference for the destroy function
function destroyWidgets(vNode, patch, index) {
    if (isWidget(vNode)) {
        if (typeof vNode.destroy === "function") {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(VPatch.REMOVE, vNode, null)
            )
        }
    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
        var children = vNode.children
        var len = children.length
        for (var i = 0; i < len; i++) {
            var child = children[i]
            index += 1

            destroyWidgets(child, patch, index)

            if (isVNode(child) && child.count) {
                index += child.count
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

// Create a sub-patch for thunks
function thunks(a, b, patch, index) {
    var nodes = handleThunk(a, b)
    var thunkPatch = diff(nodes.a, nodes.b)
    if (hasPatches(thunkPatch)) {
        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)
    }
}

function hasPatches(patch) {
    for (var index in patch) {
        if (index !== "a") {
            return true
        }
    }

    return false
}

// Execute hooks when two nodes are identical
function unhook(vNode, patch, index) {
    if (isVNode(vNode)) {
        if (vNode.hooks) {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(
                    VPatch.PROPS,
                    vNode,
                    undefinedKeys(vNode.hooks)
                )
            )
        }

        if (vNode.descendantHooks || vNode.hasThunks) {
            var children = vNode.children
            var len = children.length
            for (var i = 0; i < len; i++) {
                var child = children[i]
                index += 1

                unhook(child, patch, index)

                if (isVNode(child) && child.count) {
                    index += child.count
                }
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

function undefinedKeys(obj) {
    var result = {}

    for (var key in obj) {
        result[key] = undefined
    }

    return result
}

// List diff, naive left to right reordering
function reorder(aChildren, bChildren) {
    // O(M) time, O(M) memory
    var bChildIndex = keyIndex(bChildren)
    var bKeys = bChildIndex.keys
    var bFree = bChildIndex.free

    if (bFree.length === bChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(N) time, O(N) memory
    var aChildIndex = keyIndex(aChildren)
    var aKeys = aChildIndex.keys
    var aFree = aChildIndex.free

    if (aFree.length === aChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(MAX(N, M)) memory
    var newChildren = []

    var freeIndex = 0
    var freeCount = bFree.length
    var deletedItems = 0

    // Iterate through a and match a node in b
    // O(N) time,
    for (var i = 0 ; i < aChildren.length; i++) {
        var aItem = aChildren[i]
        var itemIndex

        if (aItem.key) {
            if (bKeys.hasOwnProperty(aItem.key)) {
                // Match up the old keys
                itemIndex = bKeys[aItem.key]
                newChildren.push(bChildren[itemIndex])

            } else {
                // Remove old keyed items
                itemIndex = i - deletedItems++
                newChildren.push(null)
            }
        } else {
            // Match the item in a with the next free item in b
            if (freeIndex < freeCount) {
                itemIndex = bFree[freeIndex++]
                newChildren.push(bChildren[itemIndex])
            } else {
                // There are no free items in b to match with
                // the free items in a, so the extra free nodes
                // are deleted.
                itemIndex = i - deletedItems++
                newChildren.push(null)
            }
        }
    }

    var lastFreeIndex = freeIndex >= bFree.length ?
        bChildren.length :
        bFree[freeIndex]

    // Iterate through b and append any new keys
    // O(M) time
    for (var j = 0; j < bChildren.length; j++) {
        var newItem = bChildren[j]

        if (newItem.key) {
            if (!aKeys.hasOwnProperty(newItem.key)) {
                // Add any new keyed items
                // We are adding new items to the end and then sorting them
                // in place. In future we should insert new items in place.
                newChildren.push(newItem)
            }
        } else if (j >= lastFreeIndex) {
            // Add any leftover non-keyed items
            newChildren.push(newItem)
        }
    }

    var simulate = newChildren.slice()
    var simulateIndex = 0
    var removes = []
    var inserts = []
    var simulateItem

    for (var k = 0; k < bChildren.length;) {
        var wantedItem = bChildren[k]
        simulateItem = simulate[simulateIndex]

        // remove items
        while (simulateItem === null && simulate.length) {
            removes.push(remove(simulate, simulateIndex, null))
            simulateItem = simulate[simulateIndex]
        }

        if (!simulateItem || simulateItem.key !== wantedItem.key) {
            // if we need a key in this position...
            if (wantedItem.key) {
                if (simulateItem && simulateItem.key) {
                    // if an insert doesn't put this key in place, it needs to move
                    if (bKeys[simulateItem.key] !== k + 1) {
                        removes.push(remove(simulate, simulateIndex, simulateItem.key))
                        simulateItem = simulate[simulateIndex]
                        // if the remove didn't put the wanted item in place, we need to insert it
                        if (!simulateItem || simulateItem.key !== wantedItem.key) {
                            inserts.push({key: wantedItem.key, to: k})
                        }
                        // items are matching, so skip ahead
                        else {
                            simulateIndex++
                        }
                    }
                    else {
                        inserts.push({key: wantedItem.key, to: k})
                    }
                }
                else {
                    inserts.push({key: wantedItem.key, to: k})
                }
                k++
            }
            // a key in simulate has no matching wanted key, remove it
            else if (simulateItem && simulateItem.key) {
                removes.push(remove(simulate, simulateIndex, simulateItem.key))
            }
        }
        else {
            simulateIndex++
            k++
        }
    }

    // remove all the remaining nodes from simulate
    while(simulateIndex < simulate.length) {
        simulateItem = simulate[simulateIndex]
        removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))
    }

    // If the only moves we have are deletes then we can just
    // let the delete patch remove these items.
    if (removes.length === deletedItems && !inserts.length) {
        return {
            children: newChildren,
            moves: null
        }
    }

    return {
        children: newChildren,
        moves: {
            removes: removes,
            inserts: inserts
        }
    }
}

function remove(arr, index, key) {
    arr.splice(index, 1)

    return {
        from: index,
        key: key
    }
}

function keyIndex(children) {
    var keys = {}
    var free = []
    var length = children.length

    for (var i = 0; i < length; i++) {
        var child = children[i]

        if (child.key) {
            keys[child.key] = i
        } else {
            free.push(i)
        }
    }

    return {
        keys: keys,     // A hash of key name to index
        free: free      // An array of unkeyed item indices
    }
}

function appendPatch(apply, patch) {
    if (apply) {
        if (isArray(apply)) {
            apply.push(patch)
        } else {
            apply = [apply, patch]
        }

        return apply
    } else {
        return patch
    }
}

},{"../vnode/handle-thunk":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/handle-thunk.js","../vnode/is-thunk":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-thunk.js","../vnode/is-vnode":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vnode.js","../vnode/is-vtext":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vtext.js","../vnode/is-widget":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-widget.js","../vnode/vpatch":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vpatch.js","./diff-props":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vtree/diff-props.js","x-is-array":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/x-is-array/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/xtend/immutable.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/trello-browser/node_modules/xtend/immutable.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/xtend/mutable.js":[function(require,module,exports){
module.exports = extend

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/h.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/h.js"][0].apply(exports,arguments)
},{"./virtual-hyperscript/index.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/virtual-hyperscript/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/node_modules/browser-split/index.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/browser-split/index.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/node_modules/ev-store/index.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/index.js"][0].apply(exports,arguments)
},{"individual/one-version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/one-version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/index.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/node_modules/individual/index.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/one-version.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/dom-delegator/node_modules/ev-store/node_modules/individual/one-version.js"][0].apply(exports,arguments)
},{"./index.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/node_modules/x-is-array/index.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/node_modules/x-is-array/index.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/virtual-hyperscript/hooks/ev-hook.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/hooks/ev-hook.js"][0].apply(exports,arguments)
},{"ev-store":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/node_modules/ev-store/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/virtual-hyperscript/index.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/index.js"][0].apply(exports,arguments)
},{"../vnode/is-thunk":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-thunk.js","../vnode/is-vhook":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-vhook.js","../vnode/is-vnode":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-vnode.js","../vnode/is-vtext":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-vtext.js","../vnode/is-widget":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-widget.js","../vnode/vnode.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/vnode.js","../vnode/vtext.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/vtext.js","./hooks/ev-hook.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/virtual-hyperscript/hooks/ev-hook.js","./hooks/soft-set-hook.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js","./parse-tag.js":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/virtual-hyperscript/parse-tag.js","x-is-array":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/node_modules/x-is-array/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/virtual-hyperscript/parse-tag.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/virtual-hyperscript/parse-tag.js"][0].apply(exports,arguments)
},{"browser-split":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/node_modules/browser-split/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-thunk.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-thunk.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-vhook.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vhook.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-vnode.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vnode.js"][0].apply(exports,arguments)
},{"./version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-vtext.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-vtext.js"][0].apply(exports,arguments)
},{"./version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-widget.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/is-widget.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/version.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/version.js"][0].apply(exports,arguments)
},{}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/vnode.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vnode.js"][0].apply(exports,arguments)
},{"./is-thunk":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-thunk.js","./is-vhook":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-vhook.js","./is-vnode":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-vnode.js","./is-widget":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/is-widget.js","./version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/vtext.js":[function(require,module,exports){
arguments[4]["/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/node_modules/virtual-dom/vnode/vtext.js"][0].apply(exports,arguments)
},{"./version":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/vnode/version.js"}],"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-elements/index.js":[function(require,module,exports){
var h = require('virtual-dom/h')

var tags = ['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']

var createElement = module.exports.createElement = function (tagName) {
  return function () {
    try {
      return h(tagName, arguments[0], [].slice.call(arguments, 1))
    } catch (e) {
      if (e.foreignObject && typeof e.foreignObject == 'number') {
        return h(tagName, arguments[0], '' + arguments[1])
      }
    }
  }
}

for (var i = 0; i < tags.length; i++) {
  var tag = tags[i]
  module.exports[tag] = createElement(tag)
}

},{"virtual-dom/h":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-dom/h.js"}],"/home/fiatjaf/comp/wft/attachments-edit/vrender-edit.coffee":[function(require,module,exports){
var Lockr, a, aside, b, button, code, dd, div, dl, dt, form, h1, h2, h3, h4, header, i, input, label, legend, li, main, nav, option, p, pre, ref, section, select, small, span, strong, table, tbody, td, textarea, tfoot, th, thead, tl, tr, ul;

Lockr = require('lockr');

tl = require('talio');

ref = require('virtual-elements'), div = ref.div, main = ref.main, span = ref.span, pre = ref.pre, nav = ref.nav, section = ref.section, header = ref.header, aside = ref.aside, small = ref.small, i = ref.i, p = ref.p, b = ref.b, a = ref.a, button = ref.button, code = ref.code, h1 = ref.h1, h2 = ref.h2, h3 = ref.h3, h4 = ref.h4, strong = ref.strong, form = ref.form, legend = ref.legend, label = ref.label, input = ref.input, textarea = ref.textarea, select = ref.select, label = ref.label, option = ref.option, table = ref.table, thead = ref.thead, tbody = ref.tbody, tfoot = ref.tfoot, tr = ref.tr, th = ref.th, td = ref.td, dl = ref.dl, dt = ref.dt, dd = ref.dd, ul = ref.ul, li = ref.li;

module.exports = function(state, channels) {
  return form({
    'ev-submit': tl.sendSubmit(channels.sendTextAsFile)
  }, header({}, input({
    title: "rename " + state.attachment.name,
    name: 'attachment.name',
    value: state.attachment.name,
    'ev-input': tl.sendChange(channels.change)
  }), button({
    type: 'submit'
  }, 'Save')), main({}, aside({}, state.user.id ? div({}, "you are connected as ", h1({}, state.user.username)) : void 0, state.card.id ? div({}, h1({}, 'Attachments '), !state.attachment.id && state.card.attachments.length ? small({}, 'choose an attachment') : void 0, button({
    'ev-click': tl.sendClick(channels.newAttachment, {
      kind: 'js'
    }, {
      preventDefault: true
    })
  }, 'new javascript'), button({
    'ev-click': tl.sendClick(channels.newAttachment, {
      kind: 'css'
    }, {
      preventDefault: true
    })
  }, 'new CSS'), button({
    'ev-click': tl.sendClick(channels.newAttachment, {
      kind: 'txt'
    }, {
      preventDefault: true
    })
  }, 'new text'), state.card.attachments.length ? ul({}, state.card.attachments.map(function(att) {
    return li({}, a({
      title: "edit or rename " + att.name,
      href: "#/b/" + state.board.id + "/c/" + state.card.id + "/a/" + att.name,
      className: att.id === state.attachment.id ? 'selected' : ''
    }, att.name, button({
      title: "delete " + att.name,
      'ev-click': tl.sendClick(channels.deleteAttachment, {
        card: state.card.id,
        attachment: att.id
      }, {
        preventDefault: true
      })
    }, '×')));
  })) : void 0) : void 0, state.board.cards.length ? div({}, h1({}, 'Cards '), !state.card.id ? small({}, 'choose a card') : void 0, ul({}, state.board.cards.map(function(c) {
    return li({}, a({
      href: "#/b/" + state.board.id + "/c/" + c.id,
      className: c.id === state.card.id ? 'selected' : ''
    }, c.name));
  }))) : void 0, state.user.boards.length ? div({}, h1({}, 'Boards '), !state.board.id ? small({}, 'choose a board') : void 0, ul({}, state.user.boards.map(function(b) {
    return li({}, a({
      href: "#/b/" + b.id,
      className: b.id === state.board.id ? 'selected' : ''
    }, b.name));
  }))) : void 0), textarea({
    title: "edit " + state.attachment.name,
    name: 'attachment.content',
    value: state.attachment.content || Lockr.get("text:" + state.card.id + "/" + state.attachment.name),
    'ev-input': tl.sendChange(channels.change)
  })));
};


},{"lockr":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/lockr/lockr.js","talio":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/index.coffee","virtual-elements":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-elements/index.js"}],"/home/fiatjaf/comp/wft/attachments-edit/vrender-main.coffee":[function(require,module,exports){
var a, article, aside, b, button, code, dd, div, dl, dt, form, h1, h2, h3, h4, header, i, input, label, legend, li, main, nav, option, p, pre, ref, section, select, small, span, strong, table, tbody, td, textarea, tfoot, th, thead, tl, tr, ul;

tl = require('talio');

ref = require('virtual-elements'), div = ref.div, main = ref.main, span = ref.span, pre = ref.pre, nav = ref.nav, section = ref.section, header = ref.header, aside = ref.aside, article = ref.article, small = ref.small, i = ref.i, p = ref.p, b = ref.b, a = ref.a, button = ref.button, code = ref.code, h1 = ref.h1, h2 = ref.h2, h3 = ref.h3, h4 = ref.h4, strong = ref.strong, form = ref.form, legend = ref.legend, label = ref.label, input = ref.input, textarea = ref.textarea, select = ref.select, label = ref.label, option = ref.option, table = ref.table, thead = ref.thead, tbody = ref.tbody, tfoot = ref.tfoot, tr = ref.tr, th = ref.th, td = ref.td, dl = ref.dl, dt = ref.dt, dd = ref.dd, ul = ref.ul, li = ref.li;

module.exports = function(state, channels) {
  return div({
    id: 'app'
  }, state.user.id ? (require('./vrender-edit'))(state, channels) : button({
    'ev-click': tl.sendClick(channels.login, {}, {
      preventDefault: true
    })
  }, "connect to Trello"));
};


},{"./vrender-edit":"/home/fiatjaf/comp/wft/attachments-edit/vrender-edit.coffee","talio":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/talio/index.coffee","virtual-elements":"/home/fiatjaf/comp/wft/attachments-edit/node_modules/virtual-elements/index.js"}]},{},["/home/fiatjaf/comp/wft/attachments-edit/app.coffee"]);
